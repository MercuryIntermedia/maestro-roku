import "pkg:/source/core/Utils.bs"

namespace mc.collections

  ' @description returns an array with items mapped by the mapper
  ' @param {array} array of items to map
  ' @param {class} mapper, function (transform):outputType, or class with a transform(item):outputType function
  ' @returns {outputType} items mapped by the mapper
  '  */
  function map(array as mc.types.array, mapper as mc.collections.BaseMapper)
    items = []
    if array <> invalid
      isClass = mc.isClass(mapper)
      for each item in array
        if isClass
          transformed = mapper.transform(item)
          if transformed <> invalid
            items.push(transformed)
          end if
        else
          transformed = mapper(item)
          if transformed <> invalid
            items.push(transformed)
          end if
        end if
      end for
    end if
    return items
  end function

  ' sorts array of items, with unique value at keyPath
  ' @params{array} arr - array to sort
  ' @params{keyPath} string - path to value to sort on
  ' @params{boolean} ascending
  function getSortedArrayByKey(arr as mc.types.array, keyPath as string, ascending = true as boolean) as mc.types.array
    result = []
    if mc.isArray(arr) and mc.isString(keyPath) and keyPath <> ""
      dict = {}
      i = 0
      for i = 0 to arr.count() - 1
        item = arr[i]
        key = mc.getPath(item, keyPath, "")
        if mc.isString(key)
          dict[key] = i
        end if
      end for
      keys = dict.keys()
      if not ascending
        keys.reverse()
      end if
      for each key in keys
        result.push(arr[dict[key]])
      end for
    end if
    return result
  end function

  function getSortedArrayByFunction(arr as mc.types.array, func as function, ascending = true as boolean) as mc.types.array
    result = []
    if mc.isArray(arr) and mc.isFunction(func)
      dict = {}
      for each item in arr
        key = func(item)
        if mc.isString(key)
          dict[key] = item
        end if
      end for
      keys = dict.keys()
      if not ascending
        keys.reverse()
      end if
      for each key in keys
        result.push(dict[key])
      end for
    end if
    return result
  end function

  function getSortedArrayByCallFunc(arr as mc.types.array, funcName as string, ascending = true as boolean) as mc.types.array
    result = []
    if mc.isArray(arr) and mc.isString(funcName)
      dict = {}
      for each item in arr
        key = item.callFunc(funcName)
        if mc.isString(key)
          dict[key] = item
        end if
      end for
      keys = dict.keys()
      if not ascending
        keys.reverse()
      end if
      for each key in keys
        result.push(dict[key])
      end for
    end if
    return result
  end function

  function getItemAtOffset(array as mc.types.array, item as dynamic, offset as integer, key = invalid as string)
    if array = invalid or array.count() = 0
      return invalid
    end if
    index = mc.collections.getArrayIndex(array, item, key)
    return array[mc.clamp(index + offset, 0, array.count() - 1)]
  end function

  function getArrayIndex(array as mc.types.array, item as dynamic, key = invalid as string)
    if array = invalid or array.count() = 0
      return -1
    end if

    itemKey = invalid
    isNode = false
    if key <> invalid
      if item <> invalid
        itemKey = item[key]
      else
        return -1
      end if
    else if type(item) = "roAssociativeArray"
      'use id as default key
      key = "id"
      itemKey = item[key]
    else if type(item) = "roSGNode"
      isNode = true
    end if

    for i = 0 to array.count() - 1
      if isNode
        if item.isSamenode(array[i])
          return i
        end if
      else if itemKey <> invalid
        if array[i] <> invalid and array[i][key] = itemKey
          return i
        end if
      else if array[i] = item
        return i
      end if
    end for
    return -1
  end function


  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ mappers
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  class BaseMapper
    function transform(item as dynamic)
    end function
  end class

  class CallFuncMapper extends mc.collections.BaseMapper
    private funcName as string
    private args as mc.types.assocarray

    function new(funcName as string, args as mc.types.assocarray)
      super()
      m.funcName = funcName
      m.args = args
    end function

    override function transform(item as dynamic)
      if item = invalid
        return invalid
      end if
      return item.callFunc(m.funcName, m.args)
    end function
  end class

  class FuncMapper extends mc.collections.BaseMapper
    private funcName as string

    function new(funcName as string)
      super()
      m.funcName = funcName
    end function

    override function transform(item as dynamic)
      if item = invalid
        return invalid
      end if
      if item[m.funcName] = invalid
        return invalid
      end if
      return item[m.funcName]()
    end function
  end class

  class FieldMapper extends mc.collections.BaseMapper
    private fieldName as string

    function new(fieldName as string)
      super()
      m.fieldName = fieldName
    end function

    override function transform(item as dynamic)
      if item = invalid
        return invalid
      end if
      return item[m.fieldName]
    end function
  end class

  ' @param {array} array of items to filter
  ' @param {class} predicate, function (item):bool, or class with a isMatch(item):bool function
  ' @returns {boolean} items that match the predicate
  function filter(array as mc.types.array, predicate as dynamic)
    items = []
    try
      if array <> invalid
        if mc.isClass(predicate)
          for each item in array
            if predicate.isMatch(item)
              items.push(item)
            end if
          end for
        else if mc.isFunction(predicate)
          for each item in array
            if predicate(item)
              items.push(item)
            end if
          end for
        else
          for each item in array
            if item = predicate
              items.push(item)
            end if
          end for
        end if
      end if
    catch error
      'bs:disable-next-line
      mc.private.logError("error while filtering items", error)
      return []
    end try

    return items
  end function

  ' @param {array} array of items to filter
  ' @param {class} predicate, function (item):bool, or class with a isMatch(item):bool function
  ' @returns {boolean} returns the first item that matches, or invalid
  function find(array as mc.types.array, predicate as dynamic, default = invalid as dynamic)
    items = mc.collections.filter(array, predicate)
    if items.count() = 0
      return default
    else
      return items[0]
    end if
  end function

  ' @param {array} array of items to filter
  ' @param {class} predicate, function (item):bool, or class with a isMatch(item):bool function
  ' @returns {boolean} returns true if the array matches the predicate
  function contains(array as mc.types.array, predicate as dynamic) as boolean
    items = mc.collections.filter(array, predicate)
    return items.count() > 0
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ filter predicates
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  class AbstractPredicate
    private expected as dynamic

    function new(expected as dynamic)
      m.expected = expected
    end function
    function isMatch(expected as dynamic) as boolean
      return false
    end function
  end class

  class ValuePredicate extends mc.collections.AbstractPredicate
    function new(expected as dynamic)
      super(expected)
    end function

    override function isMatch(item as dynamic) as boolean
      return item = m.expected
    end function
  end class

  class FieldPredicate extends mc.collections.AbstractPredicate
    private fieldName as string

    function new(fieldName as string, expected as dynamic)
      super(expected)
      m.fieldName = fieldName
    end function

    override function isMatch(item as dynamic) as boolean
      if item = invalid
        return false
      end if
      return item[m.fieldName] = m.expected
    end function
  end class

  class FuncPredicate extends mc.collections.AbstractPredicate
    private funcName as string

    function new(funcName as string, expected as dynamic)
      super(expected)
      m.funcName = funcName
    end function

    override function isMatch(item as dynamic) as boolean
      if item = invalid
        return false
      end if
      if item[m.funcName] = invalid
        return false
      end if
      compareTo = item[m.funcName]()
      return compareTo = m.expected
    end function
  end class

  class CallFuncPredicate extends mc.collections.AbstractPredicate
    private funcName as string
    private args as mc.types.assocarray

    function new(funcName as string, args as mc.types.assocarray, expected as dynamic)
      super()
      m.funcName = funcName
      m.args = args
    end function

    override function isMatch(item as dynamic) as boolean
      if item = invalid
        return false
      end if
      compareTo = item.callFunc(m.funcName, m.args)
      return m.expected = compareTo
    end function
  end class

  function arrayContains(array as mc.types.array, value as dynamic) as boolean
    return mc.collections.getArrayIndex(array, value) <> -1
  end function

end namespace
