import "pkg:/source/core/BaseClass.bs"
import "pkg:/source/ml/ListItemViewManager.bs"
import "pkg:/source/ml/ListItemScroller.bs"
import "pkg:/source/ml/List.bs"

namespace ml
  interface RowContentInfo
    row as mc.types.node
    version as integer
    isHidden as boolean
    isFocusEnabled as boolean
  end interface

  class ListContentManager extends mc.BaseClass
    public content as mc.types.node

    private list as ml.List
    private isUpdateEnabled = true

    private viewManager as ml.ListItemViewManager
    private itemScroller as ml.ListItemScroller
    private focusIndicatorManager as mc.types.node
    private rowContentInfoByContentId = {}


    function new(list as ml.List, viewManager as ml.ListItemViewManager, itemScroller as ml.ListItemScroller, focusIndicatorManager as mc.types.node)
      super("ListContentManager")
      m.list = list
      m.viewManager = viewManager
      viewManager.contentManager = m
      m.itemScroller = itemScroller
      m.focusIndicatorManager = focusIndicatorManager
    end function

    public function setContent(content as mc.types.node) as void

      if content = invalid
        ? " SETTING INVALID - RESETTING"
        content = ml.listMixin.createListContent()
        content.id = "invalidContent"
        m.content = content
        m.list.top.content = content
        m.list.cleanup()
        return
      end if

      previousContent = m.content

      m.content = content
      m.list.top.content = content

      if previousContent = invalid or not previousContent.isSameNode(content)
        ? "LCM content has changed"
        'TODO - observe something here
        m.list.resetState()
      else if content <> invalid
        'TODO - add auto checking for changes
        ' m.log.info("current content has changed in some untracked way!")
        'TODO check case where the content items mc_Array changes entirely
        m.synchronizeContent(true)
      end if
      ' m.synchronizeContent(true)
    end function

    function setUpdatesEnabled(enabled as boolean)
      m.isUpdateEnabled = enabled
    end function

    function synchronizeContent(notifyRows = true as boolean) as void
      if m.content = invalid
        ? " no content"
        return
      end if
      m.focusIndicatorManager@.setDelegateCallbacksEnabled(false)
      listResult = {
        isLayoutRequired: false
        isFocusChangeRequired: false
      }

      ? " SYNC ROWS"
      for each rowContent in m.content@.getChildren()
        info = m.rowContentInfoByContentId[rowContent.id]
        if info <> invalid
          ' m.setContentOnRow(info.row, rowContent, notifyRows, listResult)
          m.updateContentOnRow(info.row, rowContent, notifyRows, listResult)
        else
          ? " THERE SHOULD HAVE BEEN A ROW SET FOR " rowContent.id
        end if
      end for

      ? "~>~>~> AAA"
      ? " LIST CONTENT CHANGES "
      mc.collections.forEach(m.content.changes, function(item as object): ? item: end function)

      ? "~>~>~> BBB"
      if m.content.changes.count() > 0
        ? "~>~>~> CCC"
        ? "LIST CONTENT IS CHANGED "
        m.onListContentItemsChange(m.content.changes)
        listResult.isFocusChangeRequired = true
      end if

      m.focusIndicatorManager@.setDelegateCallbacksEnabled(true)
      ? "~>~>~> DDD"
      m.updateListContentIfRequired(listResult)
      ? "~>~>~> EEEE"
      if listResult.isFocusChangeRequired or listResult.isLayoutRequired
        m.updateListFocus()
      end if
    end function

    private function updateListFocus()
      ? " list has to update focus after this change"
      row = m.list.getFocusedRow()
      if row <> invalid
        row@.focusOnContentsNow()
      end if
      if m.list.top.isChildFocused or m.list.top.isFocused
        m.focusIndicatorManager@.setFocusedOnRow(true)
      end if
    end function

    private function updateContentOnRow(row as mc.types.node, content as mc.types.node, notifyRow = false as boolean, result = invalid as ml.ListChangeResult) as void
      if row = invalid
        ? "applyRowContentUpdate cannot set content on invalid row"
        return
      end if
      ? " applyRowContentUpdate "
      m.log.info("updateContentOnRow")

      isChanged = m.updateRowContentInfo(row, content, result)
      if isChanged and notifyRow
        m.applyRowContentUpdate(row, content, result)
      end if
    end function

    public function setContentOnRow(row as mc.types.node, content as mc.types.node, notifyRow = false as boolean, result = invalid as ml.ListChangeResult) as void
      if row = invalid
        ? "setContentOnRow cannot set content on invalid row"
        return
      end if
      ' ? "ON CONTENT CHANGE "; m.isInitialized
      m.log.info("setContentOnRow")

      m.updateRowContentInfo(row, content, result)
      if notifyRow
        m.applyRowContentChange(row, content, result)
      end if
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Row Methods
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    private function applyRowContentChange(row as mc.types.node, content as mc.types.node, result as ml.ListChangeResult)
      rowResult = row@.setContent(content)

      if result <> invalid
        if not result.isLayoutRequired and rowResult.isLayoutRequired
          result.isLayoutRequired = true
        end if
        if not result.isFocusChangeRequired and rowResult.isFocusChangeRequired
          result.isFocusChangeRequired = true
        end if
      end if
    end function

    private function applyRowContentUpdate(row as mc.types.node, content as mc.types.node, result as ml.ListChangeResult)
      rowResult = row@.onContentItemsChange(content)

      if result <> invalid
        if not result.isLayoutRequired and rowResult.isLayoutRequired
          result.isLayoutRequired = true
        end if
        if not result.isFocusChangeRequired and rowResult.isFocusChangeRequired
          result.isFocusChangeRequired = true
        end if
      end if
    end function

    private function updateRowContentInfo(row as mc.types.node, content as mc.types.node, result as ml.ListChangeResult) as boolean
      if row = invalid
        ? " updateRowContentInfo cannot set content on invalid row"
        return false
      end if

      isChanged = false
      newContentInfo = invalid
      oldRowContentInfo = invalid

      oldContent = row.content
      if oldContent <> invalid
        oldRowContentInfo = m.rowContentInfoByContentId[oldContent.id]
        if content = invalid
          if oldRowContentInfo <> invalid
            result.isLayoutRequired = true
            isChanged = true
          end if
          m.rowContentInfoByContentId.delete(oldContent.id)
        end if
      end if

      if content <> invalid
        newContentInfo = {
          id: content.id
          version: content.version
          isHidden: content.isHidden
          isFocusEnabled: content.isFocusEnabled
          row: row
        }
        m.rowContentInfoByContentId[content.id] = newContentInfo
      end if

      if oldRowContentInfo <> invalid and newContentInfo <> invalid
        isChanged = oldRowContentInfo.version <> newContentInfo.version
        if result <> invalid
          if oldRowContentInfo.isHidden <> newContentInfo.isHidden
            result.isLayoutRequired = true
          end if
          if oldRowContentInfo.isFocusEnabled <> newContentInfo.isFocusEnabled
            result.isFocusChangeRequired = true
          end if
        else
          'the row is either added, or removed
          result.isLayoutRequired = true
        end if
      end if

      return isChanged
    end function

    private function onRowContentItemsChange(rowContent as mc.types.node)
      ? " ROW " mc.dv(rowContent) " has changes "
      ' m.log.info("This content has changed in some way")
      ' if m.isUpdateEnabled
      '   row = m.rowsByContentId[rowContent.id]
      '   if row <> invalid
      '     row@.onContentItemsChange()
      '   else
      '     m.log.error("could not find row for content item change")
      '   end if
      ' else
      '   m.log.info("Updates are disabled. onContentItemsChange returning without updating")
      ' end if
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ List Content Methods
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    private function onListContentItemsChange(changes as mc.types.array)
      m.log.info("The list content items have changed")
      m.focusIndicatorManager@.cancelFlowFocus()
      m.viewManager.onContentItemsChange(changes)
      m.focusIndicatorManager@.cancelFlowFocus()
      m.viewManager.isScrolling = false
      m.itemScroller.isDoingFlowFocus = false
    end function

    private function updateListContentIfRequired(result as ml.ListChangeResult)
      m.log.info("processing list changes")


      ? "LCM processing list changes"
      if result.isLayoutRequired
        m.log.info("the list needs to update it's layout as a result of these changes")

        m.viewManager.forceUpdateLayout(false)

        'TODO - need to ensure that the current focus and scroll position is valid after an update! Probably want per row changes from this!
        m.itemScroller.processChanges([])
        m.list.moveToRowItemIndex(m.list.focusedRowIndex, m.list.focusedCellIndex, false)
      end if
      '// cspell:disable-next-line
      ' ? "OCIC: INDEX " ; m.itemScroller.index ; "RI"; m.focusedRowIndex
      ' m.moveToRow(m.itemScroller.index, false)
      ' ? " contents changed - moving to row " ; m.focusedRowIndex ; " " ; m.focusedCellIndex
    end function

    override function forceUpdateLayout(fullUpdate = false as boolean)
      super.forceUpdateLayout(fullUpdate)
      m.viewManager.recalculateCellInfos()
    end function

  end class
end namespace
