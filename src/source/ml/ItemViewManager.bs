import "pkg:/source/core/BaseClass.bs"
import "pkg:/source/ml/ListMixin.bs"
import "pkg:/source/ml/ItemScroller.bs"
import "pkg:/source/ml/ComponentInfo.bs"

namespace ml
  class ItemViewManager extends mc.BaseClass

    public screenRect = { translation: [0, 0], size: [1920, 1080] }
    public componentBufferMode = "none"
    private componentPool as mc.types.node

    'owning views
    'we wrap the container to make it very easy to reason about content offsets
    public container = invalid
    public owner = invalid
    public delegate = invalid
    public contentGroup = invalid
    public cellInfos = []
    private rowInfos as mc.types.array
    private renderersByContentId = {}
    private rendereredCellInfosByIndex = {}


    'tracking used for reusing cells during multi-render batches
    private previousRendereredByContentId = {}
    private reusedRenderers = []

    'content
    public content = invalid
    public rects = []
    public settings = invalid
    public listSettings = invalid

    'tracking
    public direction = 0
    public visibleItems = []
    public numberOfItems = 0
    public numberOfVisibleItems = 0

    ' 0 - x, 1 - y, 2 - both
    public axes = 0
    public minPos = 0
    public maxPos = 1080
    public lookAheadDistance = 1000
    public lookBehindDistance = 1000
    public lastScrollIndex = 0
    public lastScrollDirection = 0
    public isScrolling = false
    public scrollingStartIndex = -1
    private isRendering = false

    'TODO - move into settings or calculate this
    private renderedIndexUpdateInterval = 10

    'stored so we can send it with initialstate
    public lastScrollEvent as mc.types.assocarray
    public itemScroller as ml.ItemScroller

    protected placeHolderCell = m.createSGNode("ml_BaseCell", invalid, "#_#phc")

    function new(name as string, owner as mc.types.node, container as mc.types.node, componentPool as mc.types.node, axes as mc.types.array, minPos as integer, maxPos as integer)
      super(name)
      m.container = container
      m.contentGroup = container.getParent()
      m.componentPool = componentPool
      m.owner = owner
      m.axes = axes
      m.minPos = minPos
      m.maxPos = maxPos
      m.lastScrollDirection = 0
      m.lastScrollIndex = 0

      m.updateScreenRect()
    end function

    protected function updateScreenRect()
      'bs:disable-next-line
      bounds = m.owner.sceneBoundingRect()
      m.screenRect = { translation: [bounds.x, bounds.y], size: [m.owner.width, m.owner.height] }
    end function

    public function reset()
      m.log.info ("resetting base.itemViewManager", m.__classname)
      ' ? "RESETTING VIEW MANAGER "; m.__classname

      m.content = invalid
      m.rects = []
      m.settings = invalid

      m.direction = 0
      m.visibleItems = []
      m.numberOfItems = 0
      m.numberOfVisibleItems = 0

      m.lastScrollIndex = 0
      m.lastScrollDirection = 0
      m.isScrolling = false
      m.scrollingStartIndex = -1
      m.isRendering = false

      m.lastScrollEvent = invalid
      m.itemScroller.reset()
    end function

    function forceUpdateLayout(fullUpdate = false as boolean)
      ? "AAAforceUpdateLayout " ; mc.dv(m.top)
      m._updateLayout(fullUpdate)
    end function

    function setContent(content as mc.types.node)
      m.log.info("setContent")
      m.content = content
      m.settings = ml.listMixin.getRowSettings(m.owner.content, m.content)
      m.listSettings = m.owner.content.listSettings

      if content = invalid
        ' ? " RESETTING CONTENT"
      else
        if m._createRenderers(content) = false
          m.isRendering = true
          m.log.info("This viewManager is doing async rendering")
        else
          m.onRenderersCreated()
        end if
      end if
    end function

    function _createRenderers(content as mc.types.node) as boolean
      m.visibleItems = []

      return m.createRenderers(content)
    end function

    protected function onRenderersCreated()
      ? " RENDERERS CREATED "; m.__classname
      m.isRendering = false
      m._updateLayout()
    end function

    function _updateLayout(fullUpdate = false as boolean)
      m.log.info("_updateLayout")
      m.updateScreenRect()
      m.updateLayout(fullUpdate)
    end function

    function onFocusIndexChange(direction as integer, index as integer)
      'TODO... notify?

    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ util
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function convertChildTranslationToOwner(containerTranslation as mc.types.array)
      return [m.container.translation[0] + containerTranslation[0], m.container.translation[1] + containerTranslation[1]]
    end function

    function convertOwnerTranslationToChild(ownerTranslation as mc.types.array)
      return [m.container.translation[0] - ownerTranslation[0], m.container.translation[1] - ownerTranslation[1]]
    end function

    function setIsScrolling(isScrolling as boolean, isLong as boolean, startIndex as integer)
      ' ? m.__classname ; " setIsScrolling " ; isScrolling

      m.isScrolling = isScrolling
      m.scrollingStartIndex = isScrolling ? startIndex: -1
      m.owner.isScrolling = isScrolling

      event = {
        name: isScrolling ? "scrollStart" : "scrollStop"
        startIndex: m.scrollingStartIndex
        long: isLong
        startIndex: m.scrollingStartIndex
      }
      m.lastScrollEvent = isScrolling ? event : invalid

      if m.listSettings.sendScrollStartStop
        ' ? " SENDING SCROLL EVENTS"
        'only want this to be the components in viewPort - 'TODO make more efficient
        for each id in m.renderersByContentId
          comp = m.renderersByContentId[id]
          if comp.isInViewPort
            comp.listEvent = event
          end if
        end for
      end if
    end function

    protected function getRenderedIds()
      return m.renderersByContentId.keys()
    end function

    protected function getRenderedIndexes()
      indexes = []
      for each index in m.rendereredCellInfosByIndex
        cellInfo = m.rendereredCellInfosByIndex[index]
        indexes.push(cellInfo.index)
      end for
      return indexes
    end function

    function updateScrolling(currentIndex as integer) as void

      if currentIndex = m.scrollingStartIndex or m.scrollingStartIndex = -1
        return
      end if
      m.lastScrollEvent = {
        name: "scrollUpdate"
        startIndex: m.scrollingStartIndex
        currentIndex: currentIndex
      }
      if m.listSettings.sendScrollUpdate
        ' ? " SEND SCROLL UPDATE"
        'only send it to rendered components..
        for each id in m.renderersByContentId
          comp = m.renderersByContentId[id]
          comp.listEvent = m.lastScrollEvent
        end for
      end if
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ visibility state management
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    protected function tidyUpUnusedRenderers() as void
      ' ? "Tidying up renderers " ; m.__classname
      removedRenderers = []
      ' ? " CONTAINER HAS " ; m.container.getChildCount() - 1 ; " RENS "
      for i = 1 to m.container.getChildCount() - 1
        renderer = m.container.getChild(i)
        if renderer.content = invalid
          removedRenderers.push(renderer)
        else if m.renderersByContentId[renderer.content.id] = invalid
          removedRenderers.push(renderer)
          renderer.content = invalid
        end if
      end for
      ' ? " cleaning up "; removedRenderers.count() " renderers"
      m.componentPool@.releaseComponents(removedRenderers)
    end function


    protected override function getCell(index as integer)
      cell = invalid
      item = m.content@.getChild(index)

      if item <> invalid
        cell = m.renderersByContentId[item.id]
        if cell = invalid or cell.id = "#_#phc"
          ' ? "REPLACING PLACEHOLDER CELL AT INDEX "; index
          settings = ml.listMixin.getCellSettings(m.owner.content, m.content, item)
          cell = m.getCellForCreation(item, index, settings.compName, true, true)
          if cell <> invalid

            m.previousRendereredByContentId.delete(item.id)
            m.renderersByContentId[item.id] = cell
            m.rendereredCellInfosByIndex[index.toStr()] = m.cellInfos[index]
            cell.translation = m.rects[index].translation
            ' might have changed
            cell.index = index
            cell.initialState = {
              'bs:disable-next-line
              row: m.row
              list: m.owner
              size: m.rects[index].size
              content: item
            }

            cell.visible = true
            componentConfig = m.cellInfos[index]
            componentConfig.component = cell
          end if
          return cell
        end if
      end if
      return cell
    end function


    protected override function getCellForCreation(item as mc.types.node, index as integer, compName as string, isRendered as boolean, force as boolean)
      ' ? " GETTING CELL "; index; " isRendered "; isRendered
      ' if not isRendered and not force'index > 10 and not force
      ' if false and not isRendered and not force'index > 10 and not force
      if not isRendered and not force
        ' ? "getting placeholder"
        return m.placeHolderCell
      else
        ' ? "getting real cell"
        cell = m.componentPool@.getComponent(compName)
        if cell <> invalid
          cell.index = index
          cell.translation = m.rects[index].translation

          cell.initialState = {
            'bs:disable-next-line
            row: m.row
            list: m.owner
            size: m.rects[index].size
            content: item
          }

          cell.visible = true

          ' ? ">>>>>>>> is visible "

          if isRendered
            ' cell.listEvent = { "name": "didEnter" }
          end if

          if m.lastScrollEvent <> invalid
            cell.listEvent = m.lastScrollEvent
          end if

          m.container.appendChild(cell)
        end if
        return cell
      end if
    end function

    protected override function releaseCellAtIndex(index as integer)
      ' ? "WANT TO RELEASE " ; index
      item = m.content@.getChild(index)
      m.releasecell(m.renderersByContentId[item.id])
    end function

    protected override function releaseCell(cell as mc.types.node)
      ' ? "WANT TO RELEASE " ; index
      if cell <> invalid and cell.id <> "#_#phc"
        cellInfo = m.cellInfos[cell.index]
        m.rendereredCellInfosByIndex.delete(cellInfo.index.toStr())
        cell.isInViewPort = false
        ' ? "RELEASING THE CELL " ; index
        m.componentPool@.releaseComponent(cell)
        m.renderersByContentId[cellInfo.id] = m.placeHolderCell
        m.previousRendereredByContentId.delete(cellInfo.id)
      else
        ' ? "NOT RELEASING " ; index
      end if
    end function

    function notifyExitEvent(indexes as mc.types.array) as void
      ' ? " notifyExitEvent " ; formatJson(indexes)
      for each index in indexes
        comp = m.getRenderer(index)
        if comp <> invalid
          ' ? " notifying exit   on "; comp.id
          if comp.id <> "#_#phc"
            if comp.isInViewPort
              comp.isInViewPort = false
              comp.listEvent = {
                name: "didExit"
                direction: 1
                index: comp.index
              }
              m.releaseCellAtIndex(comp.index)
            end if
          end if
        end if
      end for
    end function

    function notifyEnterEvent(indexes as mc.types.array) as void
      ' ? " notifyEnterEvent "
      for each index in indexes
        comp = m.getRenderer(index, true)
        if comp <> invalid
          ' ? " ENTER FROM BBB" ; comp.index
          ' ? " notifying enter on "; comp.id
          if not comp.isInViewPort
            comp.isInViewPort = true
            comp.listEvent = {
              name: "didEnter"
              direction: 1
              index: comp.index
            }
          end if
        end if
      end for
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ itemRect positions
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function getFlowScreenPosition(index as integer, direction as integer)
      itemRect = m.rects[index]

      if itemRect = invalid
        m.log.warn("no itemRect for index", index)
        return invalid
      end if

      itemScreenPos = m.container.translation[m.axes] + itemRect.translation[m.axes]

      ' ? "GFSP I " ; index ; " ao: "; m.itemScroller.activeOffset ; " pos " ; itemScreenPos
      if itemScreenPos >= m.minPos and itemScreenPos + itemRect.size[m.axes] <= m.maxPos
        'we can simply move the focus to this position
        return itemScreenPos
      end if

      'if part or all of the view is off the viewport, then a scroll is required
      return invalid
    end function

    function getOffsetForScreenPosition(itemRect as object, screenPos as integer)
      if itemRect <> invalid
        return itemRect.translation[m.axes] - screenPos
      else
        return m.minPos
      end if
    end function

    function getIndexAtPosition(position as integer, direction as integer)
      p = abs(position)
      i = 0
      for i = 0 to m.cellInfos.count() - 1
        info = m.cellInfos[i]
        'the offset is already factored in
        itemPos = abs(info.getScrollOffset(direction))
        ' ? "i "; i ; "pos"; position ; " p "; p ; " ip " ; itemPos
        if itemPos > p
          ' ? "+++++!!! MATCHED ITEM INDEX "; i - skipped
          return mc.clamp(i - 1, 0, m.numberOfItems - 1)
        end if
      end for
      ' end ifk

      'we must be at the end! -return last item
      index = mc.clamp(i - 1, 0, m.numberOfItems - 1)
      ' ? "+++++!!! MATCHED ITEM INDEX "; index
      return index
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ general item api
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function getRect(index as integer, useScreenCoords = false as boolean)
      rect = m.rects[index]

      if rect <> invalid
        screenRect = {
          size: [rect.size[0], rect.size[1]]
          translation: [rect.translation[0], rect.translation[1]]
          index: rect.index
          screenPos: rect.screenPos
          subRowIndex: rect.gridrow
        }
        if useScreenCoords
          screenRect.translation = m.convertChildTranslationToOwner(screenRect.translation)
        end if
      else
        screenRect = {
          translation: [0, 0]
          size: [0, 0]
          index: -1
          screenpos: 0
          subRowIndex: -1
        }
      end if
      return screenRect
    end function

    function getFocusSettings()
      if m.settings <> invalid
        return m.settings.focusSettings
      else
        return invalid
      end if
    end function

    function getItemSettings()
      return m.settings
    end function

    function getItemSize(index as integer) as mc.types.array
      itemRect = m.rects[index]
      if itemRect <> invalid
        return itemRect.size
      else
        return [0, 0]
      end if
    end function

    function getIsOnScreen(info as ml.componentInfo, screenPos = 0 as integer) as boolean
      rect = m.rects[info.contentIndex]
      if rect = invalid
        return false
      end if
      if info.component = invalid
        'TODO - this is wrong - a component might not yet be rendered..
        info.component = m.getRenderer(info.index)
        if info.component = invalid
          ' ? " could not get renderer for this info"
          return false
        end if
      end if
      'bs:disable-next-line
      bounds = info.component.sceneBoundingRect()
      w = rect.size[0]
      h = rect.size[1]
      translation = [bounds.x, bounds.y]
      translation[m.axes] += screenPos
      return translation[0] >= m.screenRect.translation[0] and translation[0] + w <= m.screenRect.size[0] and translation[1] >= m.screenRect.translation[1] and translation[1] + h <= m.screenRect.size[1]
    end function
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ abstract methods
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function isFlowFocusPossible(info as ml.componentInfo, direction as integer, activeScreenPos as integer)
      isFlowPossible = info.isFlowFocusPossible(m.container.translation[m.axes], m.maxPos, direction, m.axes)

      if not isFlowPossible and info.isFlowFocusAllowed
        'check on the renderer
        ' ? "Flow not possible based on component info - checking actual component " ; m.screenPos ; " NI "; info.index
        isFlowPossible = m.getIsOnScreen(info, activeScreenPos)
      end if
      return isFlowPossible
    end function

    function isVerticalFlowFocusPossible(info as ml.componentInfo, direction as integer, activeScreenPos as integer)
      return true
    end function

    function createRenderers(content as mc.types.node, forceSync = false as boolean) as boolean
      m.log.error("You must override this method")
      return false
    end function

    function updateLayout(fullUpdate = false as boolean)
      m.log.error("You must override this method")
    end function

    function applyRenderStateMap(renderedStateMap as mc.types.assocarray)
      m.log.error("You must override this method")
    end function

    override function getRenderer(index as integer, createIfNotReady = false as boolean)
      ' ? " GETTING RENDERER FOR "; index
      if m.content <> invalid and m.cellInfos <> invalid
        item = m.content@.getChild(index)
        if item <> invalid
          cell = m.renderersByContentId[item.id]
          ' ? " CELL "; mc.dv(cell)
          if cell <> invalid and cell.id <> "#_#phc"
            return cell
          else if createIfNotReady
            ' ? " NO CELL calling getCell"
            return m.getCell(index)
          else
            return invalid
          end if
        else
          ' ? "ERROR could not find renderer for ", index
          return invalid
        end if
      else
        return invalid
      end if
    end function

    protected function onContentItemsChange(changes as mc.types.array)
      'override me
    end function

    protected function getRowInfos(yOffset as integer, forceRecalculate = false as boolean) as mc.types.array
      if forceRecalculate
        m.rowInfos = invalid
      end if

      if m.settings = invalid
        ' ? "+!!!!!?!! INVALID SETTINGS"
        return []
      end if
      if m.rowInfos = invalid
        focusSettings = m.getFocusSettings()

        screenPos = m.settings.screenPos
        positions = [
          new ml.ComponentPosition(yOffset, screenPos) 'normal
          new ml.ComponentPosition(yOffset, screenPos) 'float-scroll
        ]
        m.rowInfos = [new ml.ComponentInfo([0, 0], focusSettings, positions, false, 0, 0)]
      end if
      return m.rowInfos
    end function

    protected function updateChangedItems()
      for each item in m.visibleItems
        if item.version <> invalid
          renderer = m.renderersByContentId[item.id]
          if renderer <> invalid and renderer.contentVersion <> item.version
            ' m.log.info("updating renderer")
            ' ? " updating render for item version "; item.version
            renderer@.forceUpdate()
          end if
        end if
      end for
    end function

  end class
end namespace
