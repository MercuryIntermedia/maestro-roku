import "pkg:/source/ml/ItemViewManager.bs"
import "pkg:/source/ml/ComponentInfo.bs"

namespace ml
  class GridRowItemViewManager extends ml.ItemViewManager
    public row = invalid
    public cellsById = {}
    public numCols = 1
    public componentPool
    public componentBufferMode = "rendered"
    public lastRowIsRendered = "none"
    public isFlowSupported = false

    private rowOffsets = []

    function new(list as mc.types.node, row as mc.types.node, container as mc.types.node, componentPool as mc.types.node, minPos as integer, maxPos as integer)
      super("GridRowItemViewManager", list, container, 0, minPos, maxPos)
      m.componentPool = componentPool
      m.row = row

      m.lookAheadDistance = maxPos * 1.5
      m.lookBehindDistance = maxPos * 1.5
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ public api
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function getSubIndexAtPosition(position as integer, direction as integer)
      position += m.row.translation[1] 'adjust for position in the list
      p = abs(position)
      i = 0
      ' position -= m.contentGroup.translation[1] 'adjust for header offsets
      numRows = m.rowOffsets.count() - 1
      for i = numRows to 0 step -1
        itemPos = m.rowOffsets[i]
        if p >= itemPos
          return mc.clamp(i, 0, numRows)
        end if
      end for

      'we must be at the end! -return last item
      return mc.clamp(i - 1, 0, numRows)
    end function

    protected override function getRowInfos(yPosition as integer) as mc.types.array
      if m.rowInfos = invalid
        m.rowInfos = []

        height = m.owner.height

        ? "+>+>+>>+>+>++>+>+>+>>++>>+>+"
        for i = 0 to m.rowOffsets.count() - 1
          m.rowInfos.push(m.getRowInfo(i, m.rowOffsets[i], yPosition, height))
          ? "LAYING OUT ITEM " ; i ; "RO " ; m.rowOffsets[i]
        end for
        ? "+>+>+>>+>+>++>+>+>+>>++>>+>+"
      end if
      return m.rowInfos
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ overridden
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    public override function reset()
      m.log.info("releasing", m.cellsById.count(), "row children")
      for each id in m.cellsById
        m.componentPool@.releaseComponent(m.cellsById[id])
      end for
      m.cellsById = {}
      super.reset()
    end function

    override function createRenderers(content as mc.types.node, forceSync = false as boolean) as boolean
      'renderers are created as needed
      m.cellsById = {}
      return true
    end function

    override function updateLayout() as void
      m.log.info("GRID updateLayout")
      ' ? ""
      ' ? "+>+>>+>+>+>+>++>>++>>+>+>+>+>+>+>>+>+>+>+>"
      ' ? "GRID UPDATE LAYOUT"
      m.rects = []
      m.visibleComponents = []
      m.visibleItems = []
      m.rowOffsets = []
      m.rowInfos = invalid
      m.cellInfos = []

      if m.content = invalid
        return
      end if

      i = 0
      xSpace = m.settings.space
      ySpace = m.settings.rowSpace
      rowHeight = m.settings.rowHeight

      x = 0
      y = 0
      numItems = m.content.getChildCount()
      children = m.content.getChildren(-1, 0)
      m.numCols = m.settings.numColumns
      m.numCols = m.numCols < 1 ? 1 : m.numCols
      rowIndex = 0
      ' ? "children" ; formatJson(mc.collections.map(children, function(c as object)
      ' return c.title
      ' end function))

      ' ?""
      ' ?""
      ' ?""
      ' ? "LAYING OUT+++++++++++++++++++++++++++++++++"

      while i < numItems
        m.rowOffsets.push(y)

        for col = 0 to m.numCols - 1
          item = children[i]
          if item = invalid
            exit for
          end if
          ' ? "ITEM " ; item.title
          settings = ml.listMixin.getCellSettings(m.owner.content, m.content, item)
          m.rects.push({
            translation: [x, y],
            size: settings.size
            index: i
            gridRow: rowIndex
            visible: true
          })
          ' maxPos = m.maxPos - settings.size[1] - xSpace

          positions = [
            new ml.ComponentPosition(0, x) 'left
            new ml.ComponentPosition(0, x) 'fixed
            new ml.ComponentPosition(0, x) 'right
          ]

          cellInfo = new ml.ComponentInfo(settings, positions, true, i, i)
          cellInfo.index = i
          m.cellInfos.push(cellInfo)
          'TODO - for now, no vis options for rows children..
          m.visibleItems.push(item)

          x += settings.size[m.axes] + xSpace
          i++
        end for

        x = 0
        y += rowHeight + ySpace
        rowIndex++
      end while

      m.numberOfItems = m.visibleItems.count()
    end function

    private function getRowInfo(rowIndex as integer, yOffset as integer, y as integer, height as integer) as ml.ComponentInfo

      yOffset += y
      ySpace = m.settings.rowSpace
      rowHeight = m.settings.rowHeight
      maxPos = height - rowHeight - ySpace

      if rowIndex = 0
        screenPos = m.settings.firstRowScreenPos
        isFloatAllowed = false

        positions = [
          new ml.ComponentPosition(yOffset, screenPos) 'up
          new ml.ComponentPosition(yOffset, screenPos) 'fixed
          new ml.ComponentPosition(yOffset, screenPos) 'down
        ]
      else if rowIndex = 1 and m.settings.otherRowScreenPos <> m.settings.firstRowScreenPos
        screenPos = m.settings.otherRowScreenPos
        isFloatAllowed = false
        positions = [
          new ml.ComponentPosition(yOffset, screenPos) 'up
          new ml.ComponentPosition(yOffset, screenPos) 'fixed
          new ml.ComponentPosition(yOffset, screenPos) 'down
        ]
      else
        screenPos = m.settings.otherRowScreenPos
        isFloatAllowed = true
        positions = [
          new ml.ComponentPosition(yOffset, screenPos) 'up
          new ml.ComponentPosition(yOffset, screenPos) 'fixed
          new ml.ComponentPosition(yOffset, maxPos) 'down
        ]

      end if
      return new ml.ComponentInfo(m.settings, positions, isFloatAllowed, rowIndex, rowIndex)
    end function

    override function shouldUpdateRenderedIndexes(direction as integer, index as integer)
      return true
    end function

    override function applyRenderStateMap(renderStateMap as mc.types.assocarray)
      m.log.info("ROW applyRenderStateMap", m.row.index, m.row.isRendered)
      m.renderedComponents = []
      if m.row.isRendered
        for each id in renderStateMap
          m.applyrenderStateForCell(id, renderStateMap[id])
        end for
      else
        ' ? "ROW IS NOT !! RENDERED" ; m.row.index
        for each id in renderStateMap
          m.applyrenderStateForCell(id, "none")
        end for
      end if

      m.lastRowIsRendered = m.row.isRendered
    end function

    function applyrenderStateForCell(id as string, renderState as string)
      m.log.verbose("applyrenderStateForCell", id, renderState)
      index = id.toInt()
      ' isRendered = m.row.isRendered
      item = m.content.getChild(index)

      cell = invalid
      if item <> invalid
        if renderState = "rendered"
          cell = m.cellsById[item.id]
          if cell = invalid
            settings = ml.listMixin.getCellSettings(m.owner.content, m.content, item)
            ' ? "GETTING CELL " ; item.id ; " " ; settings.compName ; " " ; m.__classname
            cell = m.componentPool@.getComponent(settings.compName)

            if cell <> invalid
              cell.index = index
              cell.translation = m.rects[index].translation

              cell.initialState = {
                row: m.row
                list: m.owner
                size: m.rects[index].size
                content: item
              }

              cell.visible = true
              ' cell.visible = isRendered

              ' ? ">>>>>>>> " ; isRendered

              ' if isRendered
              cell.listEvent = { "name": "didEnter" }
              ' end if

              if m.lastScrollEvent <> invalid
                cell.listEvent = m.lastScrollEvent
              end if

              m.container.appendChild(cell)
              m.cellsById[item.id] = cell
            else
              m.log.error("could not make cell of type ", settings.compName)
            end if
          else
            cell.translation = m.rects[index].translation
            ' might have changed
            cell.index = index
            cell.initialState = {
              row: m.row
              list: m.owner
              size: m.rects[index].size
              content: item
            }

            cell.visible = true
          end if
          if cell <> invalid
            ' ? " SET cell at index "; index ;" to " ; item.id; " " ; item.title
            ' ? " RENDERED COMPS IS NOW len" ; m.renderedComponents.count()
            m.renderedComponents.push(cell)
          end if
        else
          cell = m.cellsById[item.id]
          if cell <> invalid
            ' ? "RELEASING " ; id
            m.componentPool@.releaseComponent(cell)
            m.cellsById.delete(item.id)
          else
            'this is almost certainly due to trying to release a cell during setting content
            ' ? " COULD NOT FIND CELL TO RELEASE" ; id
          end if
        end if
      end if

      componentConfig = m.cellInfos[index]
      componentConfig.component = cell
    end function

    override function getRenderer(index as integer)
      if m.content <> invalid
        item = m.content.getChild(index)
        if item <> invalid
          return m.cellsById[item.id]
        else
          m.log.error("ERROR could not find renderer for ", index)
          ? " GRID COULD NOT GET RENDERER FOR index" ; index
          return invalid
        end if
      else
        return invalid
      end if
    end function

    override function setIsScrolling(isScrolling as boolean, isLong as boolean, startIndex as integer) as void
      if m.isScrolling = isScrolling
        return
      end if
      m.scrollingStartIndex = isScrolling ? startIndex: -1
      m.isScrolling = isScrolling

      ' ? "++++ setIsScrolling" ; isScrolling
      m.row.isScrolling = isScrolling

      m.owner.isScrolling = isScrolling

      event = {
        name: isScrolling ? "scrollStart" : "scrollStop"
        startIndex: m.scrollingStartIndex
        long: isLong
        startIndex: m.scrollingStartIndex
      }
      m.lastScrollEvent = isScrolling ? event : invalid


      for each id in m.cellsById
        comp = m.cellsById[id]
        comp.listEvent = event
      end for

      m.owner.listEvent = {
        name: event.name
        index: m.row.index
        long: isLong
        startIndex: startIndex
      }
      ' ? "++++ row - listEvent " ; formatJson(m.row.listEvent)
      ' ? "++++ owner - listEvent " ; formatJson(m.owner.listEvent)
    end function

    private function getHeightOfGridRow()
      numRows = mc.clamp(m.rowOffsets.count() - 1, 0, m.settings.numRows)
      return numRows * (m.settings.rowHeight + m.settings.space) + m.settings.headerSettings.height
    end function

    private function getLastRowOffset() as integer
      if m.rowOffsets.count() > 0
        return m.rowOffsets[m.rowOffsets.count() - 1]
      else
        return 0
      end if
    end function

    private function getRowOffset(rowIndex as integer) as integer
      if m.rowOffsets.count() > rowIndex
        return m.rowOffsets[rowIndex]
      else
        return 0
      end if
    end function

    override function getComponentsInViewPort(startOffset as integer)
      compStates = {}
      'NOTE - for now, all grid items are on screen - we can tighten it up later

      ' sStart = m.screenRect.translation[m.axes] + startOffset
      ' sEnd = sStart + m.screenRect.size[m.axes]

      for each comp in m.renderedComponents
        if comp.index <> invalid
          cRect = m.rects[comp.index]
          if cRect <> invalid
            compStates[comp.id] = true
            'TODO - minimize what is in view port
            '   cStart = cRect.translation[m.axes]
            '   cEnd = cStart + cRect.size[m.axes]
            '   if (cStart >= sStart and cStart <= sEnd) or (cEnd >= sStart and cEnd <= sEnd)
            '     compStates[comp.id] = true
            '   else
            '     compStates[comp.id] = false
            '   end if
          end if
        else
          ' ? "comp index not set!"
        end if
        ' m.log.info(compStates[comp.id], "sStart", sStart, "sEnd", sENd, "cStart", cStart, "cEnd", cENd)
      end for

      return compStates
    end function

    override function getRenderedIndexes(direction as integer, index as integer)
      return {
        startIndex: 0
        endIndex: m.content = invalid ? 0 : m.visibleItems.count() - 1
      }
    end function

    protected override function onContentItemsChange(changes as mc.types.array)
      m.log.info("updating row renderers due to contents change")

      m.processRemovedCells(changes)
      m.forceUpdateLayout()
      ' m.itemScroller.processChanges(changes)
      m.updateRenderedComponents(m.itemScroller.direction, m.itemScroller.index, true)
      ' ? "+++++++++++++++++++++++++++++++++++++++++++"
      ' ? "onContentItemsChange"
      ' ? "index is " ; m.itemScroller.index ; " NI " ; m.numberOfItems
      if m.itemScroller.index < m.numberOfItems
        '  ? "IN BOUNDS"
        if m.row.isFocused
          ' ? "FOCUSED"
          m.owner@.moveToSubRowIndex(m.row.index, m.itemScroller.index, 1, false, true)
        else
          ' ? "NOT FOCUSED"
          ' m.itemScroller.setNextMoveIndex(m.itemScroller.index, 1, true)
        end if
        ' m.itemScroller.moveToSubRowIndex(m.row.index, 1, 1, false)
      else
        ' ? "OUT BOUNDS"
        if m.row.isFocused
          ' ? "FOCUSED"
          m.itemScroller.moveFromPress(- m.content.settings.numColumns, false)
        else
          ' ? "NOT FOCUSED"
          ' m.itemScroller.setNextMoveIndex(0, 1, true)
        end if
      end if
      ? "+++++++++++++++++++++++++++++++++++++++++++"
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Private Methods
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    private function processRemovedCells(changes as mc.types.array)
      m.log.info("processing removed cells")
      for each change in changes
        ' ? "GOT CHANGE TYPE "; change.type
        if change.type = "remove"
          m.log.info("removing cell at index", change.index)
          item = change.child

          if item <> invalid
            ' ? " REMOVING CELL", item.id
            cell = m.cellsById[item.id]
            if cell <> invalid
              m.componentPool@.releaseComponent(cell)
              m.cellsById.delete(item.id)
            else
              'this is almost certainly due to trying to release a cell during setting content
              ' ? "NO CELL item.id", item.id
              m.log.error("could not find cell to release", item.id)
            end if
          else
            ' ? "NO CELL item.id", change.index
            m.log.error("could not find cell to release")
          end if
        end if
      end for
    end function

  end class
end namespace