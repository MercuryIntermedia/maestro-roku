import "pkg:/source/ml/ItemViewManager.bs"

namespace ml
  class RowItemViewManager extends ml.ItemViewManager
    public row = invalid
    public cellsById = {}
    public componentPool
    public lastRowIsRendered = "none"
    public isFlowSupported = false

    function new(list as mc.types.node, row as mc.types.node, container as mc.types.node, componentPool as mc.types.node, minPos as integer, maxPos as integer)
      super("RowItemViewManager", list, container, 0, minPos, maxPos)
      m.componentPool = componentPool
      m.row = row

      m.lookAheadDistance = maxPos * 1.5
      m.lookBehindDistance = maxPos * 1.5
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ overridden
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    public override function reset()
      m.log.info("releasing", m.cellsById.count(), "row children")
      for each id in m.cellsById
        m.componentPool@.releaseComponent(m.cellsById[id])
      end for
      m.cellsById = {}
      super.reset()
    end function


    override function createRenderers(content as mc.types.node, forceSync = false as boolean) as boolean
      'renderers are created as needed
      m.cellsById = {}
      return true
    end function

    override function updateLayout() as void
      m.log.info("ROW updateLayout")
      m.rects = []
      m.visibleComponents = []
      m.visibleItems = []
      m.cellInfos = []

      m.rowInfos = invalid
      if m.content = invalid
        return
      end if

      index = 0
      ' m.contentGroup.translation = [0, 0]

      x = 0
      for each item in m.content.getChildren(-1, 0)
        ' ? ">>>> laying out ", item.title
        settings = ml.listMixin.getCellSettings(m.owner.content, m.content, item)
        xSpace = settings.space

        m.rects.push({
          translation: [x, 0],
          size: settings.size
          index: index
          rowIndex: m.row.index
          visible: true
        })
        maxPos = m.maxPos - settings.size[1] - xSpace

        positions = [
          new ml.ComponentPosition(x, 0) 'left
          new ml.ComponentPosition(x, 0) 'fixed
          new ml.ComponentPosition(maxPos, 0) 'right (float)
        ]

        cellInfo = new ml.ComponentInfo(settings, positions, true, index)
        m.cellInfos.push(cellInfo)

        'TODO - for now, no vis options for rows children..
        m.visibleItems.push(item)

        x += settings.size[m.axes] + xSpace
        index++
      end for

      m.numberOfItems = m.visibleItems.count()
    end function

    override function shouldUpdateRenderedIndexes(direction as integer, index as integer)
      return true
    end function

    override function applyRenderStateMap(renderStateMap as mc.types.assocarray)
      m.log.info("ROW applyRenderStateMap", m.row.index, m.row.isRendered)
      m.renderedComponents = []
      if m.row.isRendered
        for each id in renderStateMap
          m.applyrenderStateForCell(id, renderStateMap[id])
        end for
      else
        ' ? "ROW IS NOT !! RENDERED" ; m.row.index
        for each id in renderStateMap
          m.applyrenderStateForCell(id, "none")
        end for
      end if

      m.lastRowIsRendered = m.row.isRendered
    end function

    function applyrenderStateForCell(id as string, renderState as string)
      m.log.verbose("applyrenderStateForCell", id, renderState)
      index = id.toInt()
      ' isRendered = m.row.isRendered
      item = m.content.getChild(index)

      if item <> invalid
        if renderState = "rendered"
          cell = m.cellsById[item.id]
          if cell = invalid
            settings = ml.listMixin.getCellSettings(m.owner.content, m.content, item)
            ' ? "GETTING CELL " ; id ; " " ; settings.compName ; " " ; m.__classname
            cell = m.componentPool@.getComponent(settings.compName)

            if cell <> invalid
              cell.index = index
              cell.translation = m.rects[index].translation

              cell.initialState = {
                row: m.row
                rowIndex: m.row.index
                list: m.owner
                size: m.rects[index].size
                content: item
              }

              cell.visible = true
              ' cell.visible = isRendered

              ' ? ">>>>>>>> " ; isRendered

              ' if isRendered
              cell.listEvent = { "name": "didEnter" }
              ' end if

              if m.lastScrollEvent <> invalid
                cell.listEvent = m.lastScrollEvent
              end if

              m.container.appendChild(cell)
              m.cellsById[item.id] = cell
            else
              '      ? ">>ERR no cell for " ; settings.compName
            end if
          else
            cell.translation = m.rects[index].translation
          end if
          if cell <> invalid
            m.renderedComponents.push(cell)
          end if
        else
          cell = m.cellsById[item.id]
          if cell <> invalid
            ' ? "RELEASING " ; id
            m.componentPool@.releaseComponent(cell)
            m.cellsById.delete(item.id)
          else
            'this is almost certainly due to trying to release a cell during setting content
            ' ? " COULD NOT FIND CELL TO RELEASE" ; id
          end if
        end if
      end if
    end function

    override function getRenderer(index as integer)
      if m.content <> invalid
        item = m.content.getChild(index)
        if item <> invalid
          return m.cellsById[item.id]
        else
          ' ? "ERROR could not find renderer for ", index
          return invalid
        end if
      else
        return invalid
      end if
    end function

    override function setIsScrolling(isScrolling as boolean, isLong as boolean, startIndex as integer) as void
      if m.isScrolling = isScrolling
        return
      end if
      m.scrollingStartIndex = isScrolling ? startIndex: -1
      m.isScrolling = isScrolling

      ' ? "++++ setIsScrolling" ; isScrolling
      m.row.isScrolling = isScrolling

      m.owner.isScrolling = isScrolling

      event = {
        name: isScrolling ? "scrollStart" : "scrollStop"
        startIndex: m.scrollingStartIndex
        long: isLong
        startIndex: m.scrollingStartIndex
      }
      m.lastScrollEvent = isScrolling ? event : invalid


      for each id in m.cellsById
        comp = m.cellsById[id]
        comp.listEvent = event
      end for

      m.owner.listEvent = {
        name: event.name
        index: m.row.index
        long: isLong
        startIndex: startIndex
      }
      ' ? "++++ row - listEvent " ; formatJson(m.row.listEvent)
      ' ? "++++ owner - listEvent " ; formatJson(m.owner.listEvent)
    end function

    protected override function onContentItemsChange(changes as mc.types.array)
      m.log.info("updating row renderers due to contents change")
      ' ? "ROW CHANGES"
      m.processRemovedCells(changes)
      ' ? "FORCING LAYOUT"
      m.forceUpdateLayout()
      m.updateRenderedComponents(m.direction, m.itemScroller.index, true)
      m.itemScroller.processChanges(changes)
    end function


    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Private Methods
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    private function processRemovedCells(changes as mc.types.array)
      m.log.info("processing removed cells")
      for each change in changes
        if change.type = "remove"
          m.log.info("removing cell at index", change.index)
          item = change.child

          if item <> invalid
            cell = m.cellsById[item.id]
            if cell <> invalid
              m.componentPool@.releaseComponent(cell)
              m.cellsById.delete(item.id)
            else
              'this is almost certainly due to trying to release a cell during setting content
              m.log.error("could not find cell to release", item.id)
            end if
          else
            m.log.error("could not find cell to release")
          end if
        end if
      end for
    end function

  end class
end namespace