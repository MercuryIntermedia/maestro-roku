import "pkg:/source/ml/ItemViewManager.bs"

namespace ml
  class RowItemViewManager extends ml.ItemViewManager
    public row = invalid
    public lastRowIsRendered = "none"
    public isFlowSupported = false

    function new(list as mc.types.node, row as mc.types.node, container as mc.types.node, componentPool as mc.types.node, minPos as integer, maxPos as integer)
      super("RowItemViewManager", list, container, componentPool, 0, minPos, maxPos)
      m.row = row

      'TODO - make configurable - or calculate on cell size
      m.lookAheadDistance = maxPos * 1.5
      m.lookBehindDistance = maxPos * 1.5
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ overridden
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    public override function reset()
      m.log.info("releasing", m.renderersByContentId.count(), "row children")
      for each id in m.renderersByContentId
        m.componentPool@.releaseComponent(m.renderersByContentId[id])
      end for
      m.renderersByContentId = {}
      super.reset()
    end function


    override function createRenderers(content as mc.types.node, forceSync = false as boolean) as boolean
      ' ? "::: CREATE RENDERERS" ; m.renderersByContentId
      'renderers are created as needed
      m.previousRendereredByContentId = m.renderersByContentId
      m.rendereredCellInfosByIndex = {}
      m.renderersByContentId = {}
      return true
    end function

    override function updateLayout(fullUpdate = false as boolean) as void
      m.log.info("ROW updateLayout")
      m.rects = []
      m.visibleItems = []
      m.cellInfos = []

      m.rowInfos = invalid
      if m.content = invalid
        return
      end if

      index = 0
      ' m.contentGroup.translation = [0, 0]
      focusSettings = m.settings.focusSettings
      x = 0
      for each item in m.content@.getChildren(-1, 0)
        ' ? ">>>> laying out ", item.title
        settings = ml.listMixin.getCellSettings(m.owner.content, m.content, item)
        xSpace = settings.space

        m.rects.push({
          translation: [x, 0]
          size: settings.size
          index: index
          rowIndex: m.row.index
          visible: true
        })
        maxPos = m.maxPos - settings.size[0] - xSpace

        positions = [
          new ml.ComponentPosition(x, 0) 'normal
          new ml.ComponentPosition(x, maxPos) 'float-scroll
        ]

        cellInfo = new ml.ComponentInfo(settings.size, focusSettings, positions, focusSettings.horizAnimStyle = "floating", index, index)
        cellInfo.index = index
        cellInfo.id = item.id
        m.cellInfos.push(cellInfo)

        'TODO - for now, no vis options for rows children..
        m.visibleItems.push(item)

        x += settings.size[m.axes] + xSpace
        index++
      end for

      m.numberOfItems = m.visibleItems.count()
    end function

    override function shouldUpdateRenderedIndexes(direction as integer, index as integer)
      return true
    end function

    override function setIsScrolling(isScrolling as boolean, isLong as boolean, startIndex as integer) as void
      ' ? "++++ setIsScrolling" ; isScrolling ; " MIS " ; m.isScrolling
      if m.isScrolling = isScrolling
        return
      end if
      m.scrollingStartIndex = isScrolling ? startIndex: -1
      m.isScrolling = isScrolling

      m.row.isScrolling = isScrolling

      m.owner.isScrolling = isScrolling

      event = {
        name: isScrolling ? "scrollStart" : "scrollStop"
        startIndex: m.scrollingStartIndex
        long: isLong
        startIndex: m.scrollingStartIndex
      }
      m.lastScrollEvent = isScrolling ? event : invalid

      if m.listSettings.sendScrollStartStop

        for each id in m.renderersByContentId
          comp = m.renderersByContentId[id]
          comp.listEvent = event
        end for
      end if

      m.owner.listEvent = {
        name: event.name
        index: m.row.index
        long: isLong
        startIndex: startIndex
      }
    end function

    protected override function onContentItemsChange(changes as mc.types.array)
      m.log.info("updating row renderers due to contents change")
      ' ? "ROW CHANGES"
      oldNumComponents = m.itemScroller.numberOfComponents
      m.processRemovedCells(changes)
      ' ? "FORCING LAYOUT"
      m.forceUpdateLayout()
      ' ? m.__classname ; " I " ; m.itemScroller.index ; " C " ; m.content.length ; m.content.length
      if m.itemScroller.index >= m.content.length
        m.itemScroller.index = mc.clamp(m.itemScroller.index, 0, m.content.length - 1)
      end if
      m.itemScroller.getComponentInfos(true)
      m.itemScroller.processChanges(changes)
      ' ? " LLLL " ; m.itemScroller.numberOfComponents ; " ONC " ; oldNumComponents ; " FI "; m.itemScroller.index
      m.rowInfos = invalid
      if (m.itemScroller.numberOfComponents = 0 and oldNumComponents > 0) or (oldNumComponents = 0 and m.itemScroller.numberOfComponents > 0)
        ' ? "::::::::::::::::: SUB ITEMS ZERO CHANGE - TELL LIST"
        m.owner@.forceUpdate()
      end if
      if m.row.isFocused
        ' ? " IS FOCUSED ON" ; m.itemScroller.index
        m.itemScroller.moveToIndex(m.itemScroller.index, false)
        m.itemScroller.forceFocusOnIndex(m.itemScroller.index)
      end if
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Private Methods
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    private function processRemovedCells(changes as mc.types.array)
      m.log.info("processing removed cells")
      for each change in changes
        ' ? ">>> got change " ; change.type
        if change.type = "remove"
          m.log.info("removing cell at index", change.index)
          item = change.child

          if item <> invalid
            cell = m.renderersByContentId[item.id]
            if cell <> invalid
              m.componentPool@.releaseComponent(cell)
              m.renderersByContentId.delete(item.id)
              ' ? " DELETING INDEX "; cell.index
              m.rendereredCellInfosByIndex.delete(cell.index.toStr())
            else
              'this is almost certainly due to trying to release a cell during setting content
              m.log.error("could not find cell to release", item.id)
            end if
          else
            m.log.error("could not find cell to release")
          end if
        else if change.type = "clear" or change.type = "sort" or change.type = "updated"
          'we've reset the list - all renderers are going now
          m.renderersByContentId = {}
          m.tidyUpUnusedRenderers()
        end if
      end for
    end function

  end class
end namespace
