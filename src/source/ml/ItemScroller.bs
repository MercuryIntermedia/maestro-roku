import "pkg:/source/core/BaseClass.bs"
import "pkg:/source/view/Animation.bs"
import "pkg:/source/ml/ListMixin.bs"

#const use_debug_hacks = false

namespace ml

  class ItemScroller extends mc.BaseClass

    public rects = []
    public items = []
    public components = []
    public viewManager
    public focusManager ' this MUST be set before doing anything
    public moveAnimation
    public isMovingMultiple = false

    'rendered component maps
    public RCMap = {}
    public lastRCMap = {}
    public nextRCMap = {}
    public index = 0
    public focusedItem as mc.types.node
    public indexPosition = 0
    public focusedIndex = 0
    public nextIndex = 0
    public nextPosition = 0
    public targetIndex = 0
    public scrollStartIndex = 0
    public container as mc.types.node
    public direction = 0
    public axes = 0 'x = 0, y =1
    public screenPos = 0
    public isFloatingFocus = false
    public isWrapped = false
    public delegates = []

    private animSpeed = 0
    private settings
    private activeOffset = 0
    private nextActiveOffset = 0
    private isScrollCancelled = false

    'flow focus state
    private flowFocusIndex = -1

    'used for debugging
    protected isList = false

    function new(viewManager as ml.ItemViewManager, axes as mc.types.array)
      super("ItemScroller")
      m.viewManager = viewManager
      viewManager.itemScroller = m
      m.container = m.viewManager.container
      m.axes = axes
      m.moveAnimation = new mv.animations.Move(m.container, 1, m.container.translation, m.container.translation)
      m.moveAnimation.observeFraction(m.onAnimationFractionChange, m)
    end function

    public function onViewManagerUpdate()
      m.components = m.viewManager.visibleComponents ' content items

      m.delegates = []

      if m.viewManager.delegate <> invalid
        m.delegates.push(m.viewManager.delegate)
      end if
      m.settings = m.getFocusSettings()
    end function

    function getFocusSettings()
      if m.viewManager.content <> invalid
        return m.viewManager.content.focusSettings
      else
        return ml.listMixin.createFocusSettings()
      end if
    end function

    public function reset(keepOldFocusIfPossible = false as boolean)
      if keepOldFocusIfPossible
        index = m.index
      else
        index = 0
      end if

      m.onViewManagerUpdate()
      if keepOldFocusIfPossible
        m.setFocusIndex(index, false, true)
        m.moveToIndex(index, false, false, 0)
        m.focusManager.onFocusAnimationUpdate(1)
      else
        m.setFocusIndex(0, false, true)
        m.moveToIndex(0, false, false, 0)
        m.focusManager.onFocusAnimationUpdate(1)
      end if
      if index = invalid or index = -1
        index = 0
      end if
      'TODO need to actually set the focus properly
      m.forceFocusOnIndex(index)
    end function

    public function cancelScrolling()
      'this will force the scrolling to stop repeating if we move to another row
      if m.viewManager.isScrolling
        m.finishAnimating()
        ' m.toggleScrolling(false)
      end if
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ collection movement
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function moveToEnd(direction as integer, screenPos = invalid as integer, animated = true as boolean, fast = false as boolean) as boolean
      if (m.index >= m.viewManager.numberOfItems - 1 and direction = 1) or m.index = 0 and direction = -1
        m.log.info("already at end - ignoring")
        return false
      end if

      if direction = -1
        index = 0
      else
        index = m.viewManager.numberOfItems - 1
      end if
      ' ? "+++MVE TO END"
      m.moveToIndex(index, animated, fast)
      return true
    end function

    function moveFromPress(offset as integer, forceSequential = true as boolean) as boolean
      index = m.index + offset

      if offset > 0 and m.index = m.viewManager.numberOfItems - 1
        m.log.info("already at end")
        return false
      else if index < 0
        m.log.info("already at start")
        return false
      end if

      return m.move(offset, true, true, forceSequential)
    end function

    function move(offset as integer, animated = true as boolean, fast = false as boolean, forceSequential = true as boolean) as boolean
      ' ? "+++MOVE"
      index = m.index + offset

      if offset > 0
        if m.index = m.viewManager.numberOfItems - 1
          m.log.info("already at end")
          return false
        end if
        direction = 1
      else
        if index = -1
          m.log.info("already at start")
          return false
        end if
        direction = -1
      end if

      if m.direction = direction and abs(offset) = 1 and m.viewManager.isScrolling
        'TODO - we might want to detect this at the list, and have a cache of next move there
        m.log.info("was already scrolling - ignoring", m.viewManager.isScrolling)
        return false
      end if

      index = m.getValidTargetIndex(index, direction)

      m.log.info(`move I ${m.index} o ${offset}, i ${index}, animated ${animated}, fast ${fast}`)

      if index <> -1
        m.moveToIndex(index, animated, fast, direction, forceSequential)
      end if

      return true
    end function

    function getValidTargetIndex(index as integer, direction as integer)
      if index < 0
        index = 0
      end if

      if index >= m.viewManager.numberOfItems - 1
        index = m.viewManager.numberOfItems - 1
      end if

      matchedIndex = -1
      'TODO - check if the item is focusable..
      while true
        item = m.viewManager.visibleItems[index]
        if item = invalid
          exit while
        end if
        if item.isFocusEnabled = invalid or item.isFocusEnabled = true
          matchedIndex = index
          exit while
        end if
        index += direction
      end while

      return matchedIndex
    end function

    function moveToIndex(index as integer, animated = true as boolean, fast = false as boolean, direction = invalid as integer, forceSequential = true as boolean) as boolean
      m.log.info("moveToIndex I", m.index, "NI", index, animated)
      ' ? "MTI: I"; " "; m.index; " "; "NI"; " "; index

      ' ? "MTI: IS FLOATING " ; m.isFloatingFocus
      if direction = invalid
        direction = 0
        if index < m.index
          direction = -1
        else
          direction = 1
        end if
      end if

      itemRect = m.viewManager.rects[index]
      if itemRect <> invalid and itemRect.screenPos <> invalid
        screenPos = itemRect.screenPos
        ' ? "MTI: USE RECT SCREEN POS "; screenPos
      else
        screenPos = m.viewManager.owner.focusScreenPosition[m.axes]
        if screenPos < 0
          screenPos = 0
        end if
        ' ? "MTI: USE CURRENT screen POS "; screenPos
      end if

      nextFlowPosition = invalid
      nextIndex = m.index + direction
      m.isMovingMultiple = abs(index - m.index) > 1

      m.screenPos = m.viewManager.getScreenPositionForItem(itemRect, m.direction, not m.isFloatingFocus, screenPos)
      ' ? "AAAA"
      if m.isFloatingFocus
        ' ? "FLOATING!! " ; forceSequential
        if forceSequential
          ' ? "A1 " ; nextIndex ; " " ; direction
          nextFlowPosition = m.viewManager.getFlowScreenPosition(nextIndex, direction)
        else
          ' ? "A2 " ; index ; " " ; direction
          nextFlowPosition = m.viewManager.getFlowScreenPosition(index, direction)
        end if
        ' ? "NFP: "; nextFlowPosition
      end if

      m.direction = direction
      targetTranslation = [0, 0]

      if nextFlowPosition = invalid
        ' ? "***NO FLOW POS"
        targetTranslation = m.viewManager.getTargetTranslation(index, direction, screenPos)

        if targetTranslation = invalid
          m.log.error("cannot move! translation invalid for index", index)
          return false
        end if
        isMoveRequired = targetTranslation[m.axes] <> m.container.translation[m.axes]
      else
        ' ? "***FLOW POS"
        isMoveRequired = false
      end if


      m.targetIndex = index
      m.scrollStartIndex = m.index

      ' ? "CCC " ; isMoveRequired ; " SP " ; screenPos
      ' ? "DDD " ; nextFlowPosition
      m.log.info("moving", m.container.translation[m.axes], " > ", targetTranslation[m.axes], " pixels. animated? ", animated)
      if animated

        if forceSequential
          m.setNextIndex(m.index + m.direction)
        else
          m.setNextIndex(index)
        end if

        if fast
          m.animSpeed = m.settings.fastAnimSpeed
        else
          m.animSpeed = m.settings.animSpeed
        end if
        if not isMoveRequired
          m.log.info("already in place - no need to scroll ", m.index, " >", m.nextIndex)
          m.moveUsingFlowAnim(m.index, m.nextIndex, m.direction)
          return true
        end if

        m.toggleScrolling(true)
        ' ? ":0000"
        m.setFocusIndex(m.index, true)
        m.viewManager.updateRenderedComponents(m.direction, m.index)
        ' ? "speed"; m.animSpeed ; " target Trans "; targetTranslation ; " m.moveAnimation.fraction "; m.moveAnimation.interpolator.fraction
        m.moveAnimation.animateToWithSpeed(targetTranslation, m.animSpeed)
        m.moveAnimation.start()
      else
        m.setNextIndex(index)
        if nextFlowPosition = invalid
          m.container.translation = targetTranslation
        end if
        'TODO -check if jump is bigger than a certain amount
        ' m.viewManager.updateRenderedComponents(m.direction, m.index)
        ' m.setNextIndex(index)
        m.viewManager.updateRenderedComponents(m.direction, index)
        ' m.setFocusIndex(index, false)
        m.forceFocusOnIndex(index)
      end if

      return true
    end function

    protected function moveUsingFlowAnim(index as integer, nextIndex as integer, direction as integer)
      m.toggleScrolling(true)
      m.focusManager.setFocusPosition(index, 0, nextIndex, 0, direction)
      m.flowFocusIndex = nextIndex
      fromItem = m.viewManager.getRenderer(index)
      fromSubIndex = fromItem.focusedCellIndex
      toItem = m.viewManager.getRenderer(nextIndex)

      'we want to ask the row - "what is your index, coming from this direction?"
      toSubIndex = toItem.focusedCellIndex
      m.viewManager.owner@.startFlowFocus([index, fromSubIndex], [nextIndex, toSubIndex], m.animSpeed, mc.getTop())
    end function

    function onFlowFocusFraction(fraction as float)
      ' m.log.info("onAnimationFractionChange", fraction, "multiple", m.isMovingMultiple, "targetIndex", m.targetIndex, "FF index", m.flowFocusIndex)

      if fraction = 1
        ' ? "FINISHED FLOW " ; m.isMovingMultiple ; " TI " ; m.targetIndex
        m.focusManager.onFocusAnimationUpdate(1)
        m.index = m.flowFocusIndex
        if m.isMovingMultiple and m.targetIndex <> m.index
          m.log.info("was moving multiple, will keep moving")
          m.setFocusOnRenderer(false)
          if m.isScrollCancelled
            m.log.info("but scrolling was cancelled!")
            m.stopAnimating()
          else
            m.moveToIndex(m.targetIndex, true, true)
          end if
        else
          m.log.info("finished focusing action with this flow")
          m.targetIndex = -1
          m.setFocusOnRenderer(true)
          m.toggleScrolling(false)
        end if
      else
        m.focusManager.onFocusAnimationUpdate(fraction)
      end if

    end function

    function finishAnimating() as void
      m.isScrollCancelled = true
      'ensure that we will stop
      ' m.targetIndex = m.nextIndex
    end function

    function setNextIndex(index as integer) as void
      if index >= m.viewManager.numberOfItems
        m.log.info("cannot set index to ", index, "beyond number of vis items")
        return
      end if

      m.log.info("+++setNextIndex", index)
      if index < 0
        index = 0
      end if
      m.nextIndex = index
      #if use_debug_hacks
        mioc.setInstance("_nextIndex", m.nextIndex)
      #end if
      m.viewManager.updateScrolling(index)

      nextRect = m.viewManager.rects[m.nextIndex]
      screenPos = m.viewManager.getScreenPositionForItem(nextRect, m.direction, not m.isFloatingFocus, m.screenPos)
      ' ? "+++ SET NEXT ACTIVE OFFSET " ; index ; " " ; screenPos
      m.nextActiveOffset = screenPos
      nextTranslation = m.viewManager.getTargetTranslation(index, m.direction, screenPos)

      if nextTranslation <> invalid
        m.nextPosition = nextTranslation[m.axes]
      else
        ' ? "COULD NOT GET NEXT POSITION - USING INDEX POS"
        m.nextPosition = m.indexPosition
      end if
    end function

    function stopAnimating()
      ? "+++++++++++++++++++++"
      ? "STOP ANIMAGING"
      m.moveAnimation.stop(false)
      ' m.moveAnimation.pause()
      m.toggleScrolling(false)
    end function

    function toggleScrolling(active as boolean)
      m.viewManager.setIsScrolling(active, m.isMovingMultiple, m.index)

      m.isScrollCancelled = not active
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ animation callbacks
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function onAnimationFractionChange(fraction as float)
      ' m.log.info("onAnimationFractionChange", fraction, "multiple", m.isMovingMultiple)

      ' if m.direction = -1
      '   position = m.container.translation[m.axes]
      ' else
      position = m.container.translation[m.axes] - m.activeOffset
      ' end if

      index = m.viewManager.getIndexAtPosition(position, m.direction)
      ' ? ">> AFC " ; fraction ; " pos " ; position ; " AO " ; m.activeOffset ; " i " ; index ; " t " ; m.targetIndex ; " MI "; m.index

      if fraction = 1
        m.focusManager.onFocusAnimationUpdate(1)
        m.toggleScrolling(false)

        if index <> m.index
          m.setFocusIndex(index, false, false)
        end if
        if m.isMovingMultiple and m.targetIndex <> m.index
          m.move(m.direction)
        else
          m.targetIndex = -1
          m.isMovingMultiple = false
        end if
      else if m.isMovingMultiple
        actualPos = m.container.translation[m.axes]
        fraction = m.focusManager.onContainerPositionChange(actualPos)
        ' ? " FRACTIN "; fraction
        ' ? "++ start "; m.scrollStartIndex ; " I " ; m.index ; " posI " ; index
        'going backward requires us to increase the index, as we're always one off
        if m.direction = -1
          index += 1
        end if
        if index <> m.index and index <> m.targetIndex
          ? " CHANGE INDEX " ; index
          if m.scrollStartIndex <> m.index 'this stops a premature call to didFinishScrolling
            m.focusManager.onFocusAnimationUpdate(1)
          end if
          ? "INDEX CHANGED " ; m.index ; " > " ; index ; " POS "; position ; " IS CANCELLED " ; m.isScrollCancelled ; " fraction "; fraction

          if m.isScrollCancelled
            ? " CANCELLED " ; m.focusManager.nextPosition ; " " ; m.container.translation[m.axes]
            m.stopAnimating()
            nextPos = m.focusManager.nextPosition
            m.setFocusIndex(index, false, false)
            translation = m.container.translation
            translation[m.axes] = nextPos
            m.container.translation = translation
          else
            m.setFocusIndex(index, true)
          end if
        end if
      else
        m.focusManager.onFocusAnimationUpdate(fraction)
      end if

    end function

    ' /**
    '  * @member setFocusIndex
    '  * @memberof module:ItemScroller
    '  * @instance
    '  * @function
    '  * @description Responsible for all state updates, and hooks pertaning to focus position.
    '  *       NOTE : does NOT update position - you should be in position when calling this. for efficiency does not recalculate index: you should know the index when you call me!
    '  * @param {integer} index - the index you KNOW you are on when your move is finished (finished could mean from one index to nextindex, while animating; doesn't have to be targetIndex)
    '  * @param {boolean} isMoving - if true, then deltas are calculated for next position, and observers fired if their screen status will change
    '  */
    function setFocusIndex(index as integer, isMoving as boolean, notifyFocusManager = true as boolean) as void
      'This MUST be called infrequently
      ' TODO - check if index is actually changed
      ' ? "~~~SFI "; index ; " moving "; isMoving ; " sp "; screenPos ; " d "; m.direction
      if index = -1
        m.index = 0
        m.activeOffset = m.nextActiveOffset
        m.setNextIndex(0)
      else
        if index >= m.viewManager.numberOfItems - 1
          index = m.viewManager.numberOfItems - 1
        end if

        m.index = index
        m.activeOffset = m.nextActiveOffset
        m.setNextIndex(m.index + m.direction)
      end if

      m.focusedItem = m.viewManager.visibleItems[index]

      #if use_debug_hacks
        mioc.setInstance("_index", m.index)
        mioc.setInstance("_nextIndex", m.nextIndex)
      #end if

      'TODO -note - we need to know what screenPos WAS in a floating scenario!!
      m.indexPosition = m.viewManager.getTargetTranslation(m.index, m.direction, m.screenPos)[m.axes]

      m.viewManager.updateRenderedComponents(m.direction, m.index)

      m.notifyViewportEvents(true)

      if notifyFocusManager
        m.focusManager.setFocusPosition(m.index, m.indexPosition, m.nextIndex, m.nextPosition, m.direction)
      end if
      if isMoving
        m.setFocusOnRenderer(true, m.nextIndex)
      else
        m.setFocusOnRenderer(false)
      end if
    end function

    function forceFocusOnIndex(index as integer, notifyFocusManager = true as boolean) as void
      index = mc.clamp(index, 0, m.viewManager.numberOfItems)
      m.index = index
      m.activeOffset = m.nextActiveOffset
      m.setNextIndex(index)

      m.indexPosition = m.viewManager.getTargetTranslation(m.index, m.direction, m.screenPos)[m.axes]

      ' m.viewManager.updateRenderedComponents(m.direction, m.index)
      ' m.notifyViewportEvents(true)

      if notifyFocusManager
        m.focusManager.setFocusPosition(m.index, m.indexPosition, m.nextIndex, m.nextPosition, m.direction)
      end if
      m.focusManager.onFocusAnimationUpdate(1)

      'TODO - for cells, do we want to trigger focus events?
      if m.isList
        m.setFocusOnRenderer(false, m.index)
      end if
    end function

    function setFocusOnRenderer(isMoving as boolean, index = invalid as integer)
    end function

    function notifyViewportEvents(isMoving as boolean)
      'maintain a collection of controls that are in bounds right now:
      m.RCMap = m.viewManager.getComponentsInViewPort(- m.container.translation[m.axes])

      if isMoving and m.nextIndex <> m.index
        nextTranslation = m.viewManager.getTargetTranslation(m.nextIndex, m.direction, m.screenPos)
        m.nextRCMap = m.viewManager.getComponentsInViewPort(- nextTranslation[m.axes])
      else
        m.nextRCMap = {}
      end if

      'we assign events to each component AND send them to the owner, so it can choose what to do
      events = []

      '1. component was on screen and is going off
      'or component was not on screen and will come on.
      for each comp in m.viewManager.renderedComponents
        if comp <> invalid
          id = comp.id
          if m.nextRCMap[id] = true and comp.isInViewport <> true
            m.setCompViewPortStatus(comp, "willEnter", "none", events)
          else if m.nextRCMap[id] = false and comp.isInViewport = true
            m.setCompViewPortStatus(comp, "willExit", "didEnter", events)
          end if
        end if
      end for

      for each comp in m.viewManager.visibleComponents
        ' for each comp in m.viewManager.renderedComponents
        if comp <> invalid
          id = comp.id

          ' m.log.info(" id", id, " is in vp", comp.isInViewPort, "RCMap", m.RCMap[id], "vs", comp._vs)
          if m.RCMap[id] = true and comp.isInViewport <> true
            'ensure clients always get willEnter before didEnter
            m.setCompViewPortStatus(comp, "willEnter", "none", events)
            m.setCompViewPortStatus(comp, "didEnter", "willEnter", events)
            comp.isInViewport = true
            ' comp.visible = true
          else if m.RCMap[id] <> true and comp.isInViewPort = true

            'ensure clients always get willExit before didExit
            m.setCompViewPortStatus(comp, "willExit", "didEnter", events)
            m.setCompViewPortStatus(comp, "didExit", "willExit", events)
            comp.isInViewport = false
            ' comp.visible = false
          end if
        end if
      end for

      ' m.log.info("events")
      ' for each event in events
      '   m.log.info("event", event)
      ' end for
      m.lastRCMap = m.RCMap
      for each delegate in m.delegates
        delegate.viewportEvents = events
      end for
    end function

    function setCompViewPortStatus(comp as mc.types.node, eventName as string, validState as string, events as mc.types.array)
      if not comp.doesExist("_vs")
        comp.addFields({ _vs: "none" })
      end if

      if comp._vs = validState
        comp._vs = eventName
        event = { name: eventName, direction: m.direction, index: comp.index }
        comp.listEvent = event
        events.push(event)
      end if
    end function
  end class

end namespace