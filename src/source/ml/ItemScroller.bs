import "pkg:/source/ml/ItemScroller.bs"
import "pkg:/components/view/mixin/FocusMixin.bs"
import "pkg:/source/ml/ListItemViewManager.bs"
import "pkg:/source/core/BaseClass.bs"
import "pkg:/source/view/Animation.bs"
import "pkg:/source/ml/ListMixin.bs"
import "pkg:/source/ml/ViewPortEventNotifier.bs"

#const use_debug_hacks = false

namespace ml
  class ItemScroller extends mc.BaseClass

    public focusIndicatorManager as mc.types.node
    public container as mc.types.node
    public viewManager
    public focusManager ' this MUST be set before doing anything
    public viewPortEventNotifier
    private settings
    public isMovingMultiple = false
    public isMoveToEnd = false
    public moveToEndIndex = -1

    public isFinishingScroll = false
    public isDoingFlowFocus = false
    private isScrollCancelled = false

    public focusedItem as mc.types.node

    public index = 0
    public indexPosition = 0
    public focusedIndex = 0
    public nextIndex = 0
    public nextPosition = 0
    public targetIndex = 0
    public scrollStartIndex = 0
    public direction = 0
    public axes = 0 'x = 0, y =1
    public screenPos = 0

    @deprecated
    public isFloatingFocus = false

    public moveAnimation
    private animSpeed = 0

    private activeOffset = 0
    private nextActiveOffset = 0

    'flow focus state
    private flowFocusIndex = -1

    function new(viewManager as ml.ItemViewManager, axes as mc.types.array)
      super("ItemScroller")
      m.viewManager = viewManager
      m.focusIndicatorManager = viewManager.owner.focusIndicatorManager
      viewManager.itemScroller = m
      m.container = m.viewManager.container
      m.axes = axes
      m.viewPortEventNotifier = new ml.ViewPortEventNotifier(viewManager)
      m.moveAnimation = new mv.animations.Move(m.container, 1, m.container.translation, m.container.translation)
      m.moveAnimation.observeFraction(m.onAnimationFractionChange, m)
    end function

    public function onViewManagerUpdate()
      m.viewPortEventNotifier.onViewManagerUpdate()
      m.settings = m.getFocusSettings()
    end function

    function getFocusSettings()
      if m.viewManager.content <> invalid
        return m.viewManager.content.focusSettings
      else
        return ml.listMixin.createFocusSettings()
      end if
    end function

    public function reset(keepOldFocusIfPossible = false as boolean)
      if keepOldFocusIfPossible
        index = m.index
      else
        index = 0
      end if

      m.onViewManagerUpdate()

      if keepOldFocusIfPossible
        if index >= m.viewManager.numberOfItems
          'move to next item
          index = m.viewManager.numberOfItems - 1
        end if
      end if

      notify = m.index <> index
      notify = true
      m.setFocusIndex(index, false, true)
      m.moveToIndex(index, false, true, 0)
      m.focusManager.onFocusAnimationUpdate(1)
      if index = invalid or index = -1
        index = 0
      end if

      'TODO need to actually set the focus properly
      m.forceFocusOnIndex(index, notify)
    end function

    public function cancelScrolling()
      ? ">>> CANCEL SCROLLING ___ IS"

      'this will force the scrolling to stop repeating if we move to another row
      if m.viewManager.isScrolling
        ? "FINISH ANIM"
        m.finishAnimating()
        m.toggleScrolling(false)
      end if
    end function

    public function cancelScrollingDuringPress()
      ? ">>> CANCEL SCROLLING DURING PRESS"

      ? " TI "; m.targetIndex ; " MI "; m.index
      'this will force the scrolling to stop repeating if we move to another row
      if m.viewManager.isScrolling
        m.finishAnimating()
        m.toggleScrolling(false)
      end if
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ collection movement
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function moveToEnd(direction as integer, screenPos = invalid as integer, animated = true as boolean, fast = false as boolean) as boolean
      ? ">>>>>>>>>> MOVE TO END"
      if (m.index >= m.viewManager.numberOfItems - 1 and direction = 1) or (m.index = 0 and direction = -1)
        m.log.info("already at end - ignoring")
        return false
      end if

      m.isMoveToEnd = true
      if direction = -1
        index = 0
      else
        index = m.viewManager.numberOfItems - 1
      end if

      index = m.getValidTargetIndex(index, direction)
      m.moveToEndIndex = index

      ? "+++moveToEnd  " ; m.__classname ; " I " ; m.index; " D "; direction

      ' ? "Starting with a regular move"
      m.moveToIndex(index, animated, fast)
      return true
    end function

    function moveFromPress(offset as integer, forceSequential = true as boolean) as boolean
      ' ? "+A++++++++++++++++"
      ' m.isMoveToEnd = false
      return m.move(offset, true, true, forceSequential)
    end function

    function getIndexByAddingOffset(offset as integer) as integer
      index = m.index + offset

      if offset > 0 and m.index = m.viewManager.numberOfItems - 1
        m.log.info("already at end")
        index = m.viewManager.numberOfItems - 1
      else if index < 0
        m.log.info("already at start")
        index = 0
      end if

      return index
    end function

    function move(offset as integer, animated = true as boolean, fast = false as boolean, forceSequential = true as boolean) as boolean
      ' ? " MOVE I " ; m.index ; " O " ; offset

      index = m.index + offset
      if offset > 0
        if m.index = m.viewManager.numberOfItems - 1
          m.log.info("already at end")
          return false
        end if
        direction = 1
      else
        if index = -1
          m.log.info("already at start")
          return false
        end if
        direction = -1
      end if

      'TODO - move this into individual controls
      ' if m.direction = direction and abs(offset) = 1 and m.viewManager.isScrolling
      '   ? "===A"
      '   'TODO - we might want to detect this at the list, and have a cache of next move there
      '   ' m.log.info("was already scrolling - ignoring", m.viewManager.isScrolling)
      '   return false
      ' end if

      index = m.getValidTargetIndex(index, direction)

      ' m.log.info(`move I ${m.index} o ${offset}, i ${index}, animated ${animated}, fast ${fast}`)

      if index <> -1
        ' ? "===B"
        return m.moveToIndex(index, animated, fast, direction, forceSequential)
      end if

      return false
    end function

    function getValidTargetIndex(index as integer, direction as integer)
      if index < 0
        index = 0
      end if

      if index >= m.viewManager.numberOfItems - 1
        index = m.viewManager.numberOfItems - 1
      end if

      if direction = 0
        direction = 1
      end if
      matchedIndex = -1
      'TODO - check if the item is focusable..
      while true
        item = m.viewManager.visibleItems[index]
        if item = invalid
          exit while
        end if
        ? " ITEM "; item.title ; " is hidden" ; item.isHidden
        if item.isHidden = invalid or item.isHidden = false
          if item.isFocusEnabled = invalid or item.isFocusEnabled = true
            matchedIndex = index
            exit while
          end if
        end if
        index += direction
      end while

      ? " GVTI "; index; " MI "; matchedIndex
      return matchedIndex
    end function

    function moveToIndex(index as integer, animated = true as boolean, fast = false as boolean, direction = invalid as integer, forceSequential = true as boolean) as boolean
      m.log.info("moveToIndex I", m.index, "NI", index, animated)
      ? " MTI " ; index ; " d " ; direction

      m.isFinishingScroll = false

      if direction = invalid
        direction = 0
        if index < m.index
          direction = -1
        else
          direction = 1
        end if
      end if
      ? "REGULAR MOVE TO INDEX: I"; " "; m.index; " "; "NI"; index ; m.__classname ; " DIR "; direction ; " sP "; m.screenPos


      '////////////////////////////////////////////////////////////////////////
      ' 1. get the ideal screen position for the item
      '////////////////////////////////////////////////////////////////////////
      itemRect = m.viewManager.rects[index]
      if itemRect <> invalid and itemRect.screenPos <> invalid
        screenPos = itemRect.screenPos
        ? "MTI: USE RECT SCREEN POS "; screenPos
      else if m.isFloatingFocus
        ? "MTI: USE CURRENT screen POS "; screenPos
        screenPos = m.focusIndicatorManager.focusScreenPosition[m.axes]
        if screenPos < 0
          screenPos = 0
        end if
      else
        '      ? "MTI: no screenpos"
        screenPos = 0
      end if

      m.isMovingMultiple = abs(index - m.index) > 1

      m.screenPos = m.viewManager.getScreenPositionForItem(itemRect, m.direction, not m.isFloatingFocus, screenPos)

      ' ? "::::::::::::::::: screenPos" ; m.screenPos
      '////////////////////////////////////////////////////////////////////////
      ' 2. ascertain if the next item is on screen, and can be flow animated to
      '////////////////////////////////////////////////////////////////////////

      'floating focus is not supported outside of grids, at this time

      nextFlowPosition = invalid
      if m.isFloatingFocus
        m.log.error("floating focus is not supported")
        ? "FLOATING!! " ; forceSequential
        ' if forceSequential
        '   '      ? "A1 " ; nextIndex ; " " ; direction
        '   nextFlowPosition = m.viewManager.getFlowScreenPosition(nextIndex, direction)
        ' else
        '   '      ? "A2 " ; index ; " " ; direction
        '   nextFlowPosition = m.viewManager.getFlowScreenPosition(index, direction)
        ' end if
        ' '      ? "NFP: "; nextFlowPosition
      end if

      m.direction = direction
      targetTranslation = [0, 0]

      if nextFlowPosition = invalid
        '////////////////////////////////////////////////////////////////////////
        ' 2.b - no flow position - where does the view have to animate to?
        '////////////////////////////////////////////////////////////////////////
        ? "2.b - no flow pos screenPos "; screenPos
        targetTranslation = m.viewManager.getTargetTranslation(index, direction, screenPos)

        if targetTranslation = invalid
          m.log.error("cannot move! translation invalid for index", index)
          return false
        end if

        offset = 0

        targetTranslation[1] -= offset
        isMoveRequired = targetTranslation[m.axes] <> m.container.translation[m.axes]
      else
        '      ? "***FLOW POS"
        isMoveRequired = false
      end if

      ? "SET TARGET INDEX MOVE TO INDEX" ; index ; " " ; m.__classname
      m.setTargetIndex(index)
      m.scrollStartIndex = m.index

      '      ? "CCC " ; isMoveRequired ; " SP " ; screenPos
      '      ? "DDD " ; nextFlowPosition
      ' m.log.info("moving", m.container.translation[m.axes], " > ", targetTranslation[m.axes], " pixels. animated? ", animated)
      ' m.viewManager.owner@.cancelFlowFocus()

      if animated
        '////////////////////////////////////////////////////////////////////////
        ' 3. do an animated move
        '////////////////////////////////////////////////////////////////////////

        ? " 3. animating  SEQUENTIAL: " ; forceSequential
        if forceSequential
          m.setNextIndex(m.index + m.direction)
        else
          m.setNextIndex(index)
        end if

        if fast
          m.animSpeed = m.settings.fastAnimSpeed
        else
          m.animSpeed = m.settings.animSpeed
        end if

        if not isMoveRequired
          '////////////////////////////////////////////////////////////////////////
          ' 3.a it's a flow animation
          '////////////////////////////////////////////////////////////////////////
          m.log.info("already in place - no need to scroll ", m.index, " >", m.nextIndex)
          ? " IN PLACE " ; m.__classname
          m.moveUsingFlowAnim(m.index, m.nextIndex, m.direction)
          return true
        end if

        '////////////////////////////////////////////////////////////////////////
        ' 3.b it's a regular container animation
        '////////////////////////////////////////////////////////////////////////

        ? ">>>> START ANIM ; REGULAR CONTAINER ANIM - moveToIndex "; formatJson(targetTranslation) ; " SPEED "; m.animSpeed ; " " ; m.__classname
        m.toggleScrolling(true)
        m.setFocusIndex(m.index, true)
        m.viewManager.updateRenderedComponents(m.direction, m.index)
        m.moveAnimation.animateToWithSpeed(targetTranslation, m.animSpeed)
        m.moveAnimation.start()
      else
        '////////////////////////////////////////////////////////////////////////
        ' 4. non-animated move
        '////////////////////////////////////////////////////////////////////////

        'TODO - deal with case where the item @ index is MultiRow
        m.setNextIndex(index)
        if nextFlowPosition = invalid
          m.container.translation = targetTranslation
        end if
        'TODO -check if jump is bigger than a certain amount
        ' m.viewManager.updateRenderedComponents(m.direction, m.index)
        ' m.setNextIndex(index)
        m.viewManager.updateRenderedComponents(m.direction, index)
        ' m.setFocusIndex(index, false)
        m.forceFocusOnIndex(index)
      end if

      return true
    end function

    protected function moveUsingFlowAnim(index as integer, nextIndex as integer, direction as integer)
      m.toggleScrolling(true)
      m.focusManager.setFocusPosition(index, 0, nextIndex, 0, direction)
      m.flowFocusIndex = nextIndex
      fromItem = m.viewManager.getRenderer(index)
      fromSubRowIndex = fromItem.focusedCellIndex
      toItem = m.viewManager.getRenderer(nextIndex)

      ' ? " DOING FLOW ANIM " ;m.animSpeed
      'we want to ask the row - "what is your index, coming from this direction?"
      toSubRowIndex = toItem.focusedCellIndex
      m.viewManager.owner@.startFlowFocus([index, fromSubRowIndex], [nextIndex, toSubRowIndex], m.animSpeed, mc.getTop())
    end function

    function onFlowFocusFraction(fraction as float)
      ? "on FLow fraction"; fraction ; m.__classname
      ' m.log.info("onFlowFocusFraction", fraction, "multiple", m.isMovingMultiple, "targetIndex", m.targetIndex, "FF index", m.flowFocusIndex)

      if fraction = 1
        ' ? "FINISHED FLOW " ; m.__classname ; " multiple: " ; m.isMovingMultiple ; " TI " ; m.targetIndex
        m.focusManager.onFocusAnimationUpdate(1)
        m.setIndex(m.flowFocusIndex)
        m.log.info("finished focusing action with this flow")
        '      ? "RESET TARGET INDEX onFlowFocusFraction finished"
        m.setFocusOnRenderer(true)
        m.toggleScrolling(false)
      else
        m.focusManager.onFocusAnimationUpdate(fraction)
      end if

    end function

    function finishAnimating() as void
      m.finishMovingToIndex()
    end function

    function finishMovingToIndex(screenPos = invalid as integer) as boolean
      index = m.nextIndex
      itemRect = m.viewManager.rects[index]
      m.isMovingMultiple = false
      ? "+++++++FINISH MOVING TO INDEX "
      m.isMoveToEnd = false

      if m.isDoingFlowFocus
        m.isDoingFlowFocus = false
        m.toggleScrolling(false)
        return false
      end if

      if itemRect = invalid
        ? "+++++++ NO ITEM RECT"
        m.toggleScrolling(false)
        return false
      end if

      if screenPos = invalid and itemRect <> invalid
        screenPos = itemRect.screenPos
        ' screenPos = m.screenPos
      end if

      ' m.viewManager.owner@.cancelFlowFocus()

      targetTranslation = m.viewManager.getTargetTranslation(index, m.direction, screenPos)

      if targetTranslation = invalid
        m.log.error("cannot move! translation invalid for index", index)
        ' ? "+++++++ NO TARGET TRANSLATION"
        m.toggleScrolling(false)
        return false
      end if

      m.screenPos = m.viewManager.getScreenPositionForItem(itemRect, m.direction, not m.isFloatingFocus, screenPos)
      ' ? "SET TARGET INDEX FROM FINISH MOVING TO INDEX"
      m.setTargetIndex(index)

      'TODO - take into account floating focus
      isMoveRequired = targetTranslation[m.axes] <> m.container.translation[m.axes]
      'can only be animated
      m.animSpeed = m.settings.animSpeed
      m.isFinishingScroll = true

      if not isMoveRequired
        if m.focusedIndex = index
          m.log.info("already in place")
          m.toggleScrolling(false)
          return false
        end if
        m.log.info("already in place - no need to scroll ", index, " >", m.nextIndex)
        ? "+++++++ IN PLACE"
        m.moveUsingFlowAnim(index, m.nextIndex, m.direction)
        return true
      end if

      ? "++++++++ START ANIM ; already scrolling - finish moving to index  " ; index
      'TODO ascertain if this is a sub move
      'we are already scrolling
      m.moveAnimation.animateToWithSpeed(targetTranslation, m.animSpeed)
      m.moveAnimation.start()
      return true
    end function

    function setNextIndex(index as integer) as void
      if index >= m.viewManager.numberOfItems
        m.log.info("cannot set index to ", index, "beyond number of vis items")
        return
      end if

      if m.nextIndex = index
        return
      end if

      m.log.info("+++setNextIndex", index)
      if index < 0
        index = 0
      end if
      m.nextIndex = index
      #if use_debug_hacks
        mioc.setInstance("_nextIndex", m.nextIndex)
      #end if
      m.viewManager.updateScrolling(index)

      nextRect = m.viewManager.rects[m.nextIndex]

      screenPos = m.viewManager.getScreenPositionForItem(nextRect, m.direction, not m.isFloatingFocus, m.screenPos)

      m.nextActiveOffset = screenPos
      nextTranslation = m.viewManager.getTargetTranslation(index, m.direction, screenPos)

      if nextTranslation <> invalid
        m.nextPosition = nextTranslation[m.axes]
      else
        '      ? "COULD NOT GET NEXT POSITION - USING INDEX POS"
        m.nextPosition = m.indexPosition
      end if
    end function

    function stopAnimating()
      '      ? "+++++++++++++++++++++"
      '      ? "STOP ANIMAGING"
      m.moveAnimation.stop(false)
      ' m.moveAnimation.pause()
      m.toggleScrolling(false)
    end function

    function toggleScrolling(active as boolean)
      m.viewManager.setIsScrolling(active, m.isMovingMultiple, m.index)
      ? " toggleScrolling " ; active ; " " ; m.__classname

      if not active
        m.setTargetIndex(-1)
        m.isMovingMultiple = false
      end if
      m.isScrollCancelled = not active
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ animation callbacks
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function onAnimationFractionChange(fraction as float) as void
      ' m.log.info("onAnimationFractionChange", fraction, "multiple", m.isMovingMultiple)

      ' ? " ACTIVE OFFSET "; m.activeOffset ; " NAO "; m.nextActiveOffset ; " F "; fraction ; " "

      if m.direction = -1 'and m.subRowIndex = -1
        position = m.container.translation[m.axes] - m.nextActiveOffset
      else
        position = m.container.translation[m.axes] - m.activeOffset
      end if

      index = m.viewManager.getIndexAtPosition(position, m.direction)
      ? ">> AFC " ; fraction ; " pos " ; position ; " AO " ; m.activeOffset ; " i " ; index ; " t " ; m.targetIndex ; " MI "; m.index

      if fraction = 1
        ? " REGULAR MOVE: FRACTION 1 FINAL INDEX " ; index ; " m.i "; m.index
        m.focusManager.onFocusAnimationUpdate(1)

        if index <> m.index
          m.setFocusIndex(index, false, false)
        end if

        ? "RESET TARGET INDEX onAnimationFractionChange 1"
        m.toggleScrolling(false)
      else if (m.isMoveToEnd) or m.isFinishingScroll
        ' ? " D " ; m.direction ; " m.I " ; m.index ; " I "; index ; " DIFF " ; abs(m.index - index)

        if (m.direction = -1 and (index >= m.index)) or (m.direction = 1 and (index < m.index))
          '      ? " skipping focus calc error"
          return
        end if

        actualPos = m.container.translation[m.axes]
        fraction = m.focusManager.onContainerPositionChange(actualPos)
        ' ? "++ start "; m.scrollStartIndex ; " I " ; m.index ; " posI " ; index
        'going backward requires us to increase the index, as we're always one off
        if m.direction = -1
          index += 1
        end if
        if index <> m.index and index <> m.targetIndex
          ? "+(+(+(+(+(++(+(+(+(+ CHANGE INDEX " ; m.index " > "; index
          if m.scrollStartIndex <> m.index 'this stops a premature call to didFinishScrolling
            m.focusManager.onFocusAnimationUpdate(1)
          end if

          m.setFocusIndex(index, true)

        end if
      else
        'simple one keypress case
        m.focusManager.onFocusAnimationUpdate(fraction)
      end if

    end function

    ' /**
    '  * @member setFocusIndex
    '  * @memberof module:ItemScroller
    '  * @instance
    '  * @function
    '  * @description Responsible for all state updates, and hooks pertaning to focus position.
    '  *       NOTE : does NOT update position - you should be in position when calling this. for efficiency does not recalculate index: you should know the index when you call me!
    '  * @param {integer} index - the index you KNOW you are on when your move is finished (finished could mean from one index to nextindex, while animating; doesn't have to be targetIndex)
    '  * @param {boolean} isMoving - if true, then deltas are calculated for next position, and observers fired if their screen status will change
    '  */
    function setFocusIndex(index as integer, isMoving as boolean, notifyFocusManager = true as boolean) as void
      'This MUST be called infrequently
      ' TODO - check if index is actually changed
      '      ? "~~~SFI "; index ; " moving "; isMoving ; " d "; m.direction

      if index = -1
        m.setIndex(0)
        m.activeOffset = m.nextActiveOffset
        m.setNextIndex(0)
      else
        if index >= m.viewManager.numberOfItems - 1
          index = m.viewManager.numberOfItems - 1
        end if

        m.setIndex(index)
        m.activeOffset = m.nextActiveOffset
        nextIndex = m.getValidTargetIndex(m.index + m.direction, m.direction)
        m.setNextIndex(nextIndex)
      end if

      m.focusedItem = m.viewManager.visibleItems[index]

      #if use_debug_hacks
        mioc.setInstance("_index", m.index)
        mioc.setInstance("_nextIndex", m.nextIndex)
      #end if

      'TODO -note - we need to know what screenPos WAS in a floating scenario!!
      m.indexPosition = m.viewManager.getTargetTranslation(m.index, m.direction, m.screenPos)[m.axes]

      m.viewManager.updateRenderedComponents(m.direction, m.index)

      m.viewPortEventNotifier.notifyViewportEvents(m.index, m.nextIndex, m.direction, m.screenPos, true)

      if notifyFocusManager
        m.focusManager.setFocusPosition(m.index, m.indexPosition, m.nextIndex, m.nextPosition, m.direction)
      end if
      if isMoving
        m.setFocusOnRenderer(true, m.nextIndex)
      else
        m.setFocusOnRenderer(false)
      end if
    end function

    function forceFocusOnIndex(index as integer, notifyFocusManager = true as boolean) as void
      index = mc.clamp(index, 0, m.viewManager.numberOfItems)
      m.setIndex(index)
      m.activeOffset = m.nextActiveOffset
      m.setNextIndex(index)

      m.indexPosition = m.viewManager.getTargetTranslation(m.index, m.direction, m.screenPos)[m.axes]

      ' m.viewManager.updateRenderedComponents(m.direction, m.index)
      ' m.notifyViewportEvents(true)

      if notifyFocusManager
        m.focusManager.setFocusPosition(m.index, m.indexPosition, m.nextIndex, m.nextPosition, m.direction)
      end if
      m.focusManager.onFocusAnimationUpdate(1)

      'TODO - for cells, do we want to trigger focus events?
      m.setFocusOnRenderer(false, m.index)
    end function

    protected function setTargetIndex(index as integer)
      '      ? "setting targetIndex to "; index ; " "; m.__classname
      m.targetIndex = index
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ public methods
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function canMove(direction as integer) as boolean
      ' ? "I " ; m.index ; " NI " ; m.viewManager.numberOfItems ; " NC " ; m.viewManager.numCols; " D " ; direction
      ' ? "BBB" ; (direction = -1 and m.index > 0) or (direction = 1 and m.index < m.viewManager.numberOfItems - 1)
      return (direction = -1 and m.index > 0) or (direction = 1 and m.index < m.viewManager.numberOfItems - 1)
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ overridden
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function setFocusOnRenderer(isMoving as boolean, index = invalid as integer) as void
      m.log.info("setFocusOnRenderer", isMoving, index)
      row = invalid
      ' if isMoving
      '   return
      ' end if
      if index <> invalid
        row = m.viewManager.getRenderer(index)
      else
        row = m.viewManager.getRenderer(m.index)
      end if

      if row <> invalid and (m.viewManager.owner.isChildFocused or m.viewManager.owner.isFocused)
        mv.setFocus(row)
      else
        m.log.warn("not setting focus on", index, "owner child focused?", m.viewManager.owner.isChildFocused, "owner focused?", m.viewManager.owner.isFocused)
      end if
    end function

    protected function setIndex(index as integer)
      m.index = index
    end function

    protected function processChanges(changes as mc.types.array) as void
      isIndexUpdateRequired = false
      if m.index >= m.viewManager.numberOfItems
        'try down first
        index = m.getValidTargetIndex(m.index, 1)
        if index = -1
          index = m.getValidTargetIndex(m.index, -1)
        end if
        if index = -1
          index = 0
        end if
        ? "index is changing " ; m.index ; " > " ; index
        m.index = index
        isIndexUpdateRequired = true
      end if
      if not isIndexUpdateRequired
      isIndexUpdateRequired = mc.collections.contains(changes, function(c as mc.types.assocarray)
        return c.index <> invalid and c.index <> m.index or (c.type = "sort" or c.type = "change" or c.type = "updated" or c.type = "isHidden" or c.type = "isFocusEnabled")
      end function)
    end if

    'all changes result in downward movements
    ' m.direction = 1
    ? "LIST PROCESS INDEX CHANGES", isIndexUpdateRequired, m.index, m.viewManager.numberOfItems
    if isIndexUpdateRequired
      ? " NOTIFYING FOCUS"
      ? ">>>>>>>>>> ITEM SCROLLER INDEX IS NOW" ; m.index
      wasNotifying = m.focusManager.isNotifying
      m.focusManager.isNotifying = true
      m.reset(true)
      m.focusManager.isNotifying = wasNotifying

    else
      ? " not notifying focus"
      m.reset(true)
    end if
  end function

end class
end namespace